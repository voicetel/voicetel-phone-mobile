<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
		/>
		<title>VoiceTel Phone v3.5.6</title>
		<link rel="icon" type="image/png" href="favicon.png" />

		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			html {
				overflow-x: hidden;
				width: 100%;
				-webkit-text-size-adjust: 100%;
			}

			body {
				font-family:
					-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
					Oxygen, Ubuntu, sans-serif;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				min-height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				padding: 20px;
				overflow-x: hidden;
				width: 100%;
				position: relative;
				-webkit-overflow-scrolling: touch;
			}

			.container {
				background: white;
				border-radius: 20px;
				box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
				max-width: 500px;
				width: 100%;
				overflow: hidden;
				position: relative;
				margin: 0 auto;
			}

			.header {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				padding: 30px;
				text-align: left;
				position: relative;
			}

			.header h1 {
				font-size: 28px;
				margin-bottom: 10px;
			}

			.status {
				display: inline-block;
				padding: 5px 15px;
				border-radius: 20px;
				background: rgba(255, 255, 255, 0.2);
				font-size: 14px;
				margin-top: 10px;
			}

			.status.registered {
				background: rgba(76, 175, 80, 0.3);
			}

			.header-buttons {
				position: absolute;
				top: 20px;
				right: 20px;
				display: flex;
				gap: 8px;
			}

			.header-toggle {
				background: rgba(255, 255, 255, 0.2);
				border: none;
				color: white;
				width: 40px;
				height: 40px;
				border-radius: 50%;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 20px;
				transition: all 0.3s;
			}

			.header-toggle:hover {
				background: rgba(255, 255, 255, 0.3);
				transform: rotate(90deg);
			}

			.header-toggle.active {
				background: rgba(255, 255, 255, 0.4);
			}

			.content {
				padding: 30px;
				overflow-x: hidden;
				width: 100%;
				box-sizing: border-box;
			}

			.section {
				margin-bottom: 25px;
				overflow-x: hidden;
				width: 100%;
				box-sizing: border-box;
			}

			.section.config-section {
				max-height: 0;
				overflow: hidden;
				transition:
					max-height 0.4s ease-out,
					margin-bottom 0.4s ease-out;
				margin-bottom: 0;
			}

			.section.config-section.visible {
				max-height: 1000px;
				margin-bottom: 25px;
			}

			.section.log-section {
				max-height: 0;
				overflow: hidden;
				transition:
					max-height 0.4s ease-out,
					margin-bottom 0.4s ease-out;
				margin-bottom: 0;
			}

			.section.log-section.visible {
				max-height: 800px;
				margin-bottom: 25px;
			}

			#historySection.visible {
				margin-bottom: 25px;
			}

			#historySection .log {
				padding: 20px;
				max-height: 400px;
				border-radius: 12px;
				overflow-y: auto;
			}

			.history-actions,
			.contacts-actions {
				display: flex;
				gap: 10px;
				margin-top: 12px;
				padding: 0;
				width: calc(100% - 40px);
				margin-left: 20px;
				margin-right: 20px;
				box-sizing: border-box;
				overflow-x: hidden;
				flex-wrap: wrap;
			}

			.history-actions button,
			.contacts-actions button {
				flex: 1 1 auto;
				min-width: 0;
				max-width: 100%;
			}

			#contactsSection .log {
				padding: 20px;
				max-height: 400px;
				border-radius: 12px;
				overflow-y: auto;
			}

			.contact-item {
				padding: 16px 20px;
				border-bottom: 1px solid #f0f0f0;
				cursor: pointer;
				transition: all 0.2s ease;
				background: white;
			}

			.contact-item:hover {
				background-color: #f8f9fa;
				transform: translateX(2px);
			}

			.contact-item:last-child {
				border-bottom: none;
			}

			.contact-item:active {
				background-color: #e9ecef;
			}

			#historySection .log-entry {
				display: flex;
				justify-content: space-between;
				align-items: baseline;
				gap: 12px;
				padding: 10px 12px;
				margin-bottom: 8px;
				background: #fff;
				border-radius: 8px;
			}

			.section.hideable {
				display: block;
				transition: opacity 0.3s ease-out;
			}

			.section.hideable.hidden {
				display: none;
			}

			.section h2 {
				font-size: 18px;
				color: #333;
				margin-bottom: 15px;
				padding-bottom: 8px;
				border-bottom: 2px solid #f0f0f0;
			}

			.form-group {
				margin-bottom: 15px;
			}

			.form-group label {
				display: block;
				margin-bottom: 5px;
				color: #666;
				font-size: 14px;
			}

			.form-group label small {
				font-weight: normal;
				display: block;
				margin-top: 2px;
			}

			.form-group input[type="checkbox"] {
				width: auto;
				margin-right: 8px;
			}

			.form-group input {
				width: 100%;
				padding: 10px;
				border: 2px solid #e0e0e0;
				border-radius: 8px;
				font-size: 14px;
				transition: border-color 0.3s;
			}

			.form-group input:focus {
				outline: none;
				border-color: #667eea;
			}

			.button-group {
				display: flex;
				gap: 10px;
				margin-top: 15px;
				overflow-x: hidden;
				width: 100%;
				box-sizing: border-box;
			}

			button {
				flex: 1;
				padding: 12px 20px;
				border: none;
				border-radius: 8px;
				font-size: 14px;
				font-weight: 600;
				cursor: pointer;
				transition: all 0.3s;
			}

			.btn-primary {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
			}

			.btn-primary:hover {
				transform: translateY(-2px);
				box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
			}

			.btn-success {
				background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
				color: white;
			}

			.btn-danger {
				background: linear-gradient(135deg, #f44336 0%, #da190b 100%);
				color: white;
			}

			.btn-secondary {
				background: #f0f0f0;
				color: #333;
			}

			.btn-secondary.recording {
				background: linear-gradient(135deg, #f44336 0%, #da190b 100%);
				color: white;
				animation: pulse 2s infinite;
			}

			@keyframes pulse {
				0%,
				100% {
					opacity: 1;
				}
				50% {
					opacity: 0.7;
				}
			}

			button:disabled {
				opacity: 0.5;
				cursor: not-allowed;
			}

			.call-controls {
				display: none;
				text-align: center;
				padding: 20px;
				background: #f8f8f8;
				border-radius: 12px;
				margin-top: 20px;
				overflow-x: hidden;
				width: 100%;
				box-sizing: border-box;
			}

			.call-controls.active {
				display: block;
			}

			.call-info {
				font-size: 16px;
				color: #666;
				margin-bottom: 15px;
				overflow-x: hidden;
				word-wrap: break-word;
			}

			.dialpad {
				display: grid;
				grid-template-columns: repeat(3, 1fr);
				gap: 10px;
				max-width: 250px;
				margin: 20px auto;
			}

			.dialpad button {
				aspect-ratio: 1;
				font-size: 20px;
				background: white;
				border: 2px solid #e0e0e0;
				color: #333;
			}

			.dialpad button:hover {
				background: #f0f0f0;
				transform: none;
				box-shadow: none;
			}

			.dialpad-layer {
				background: white;
				border-radius: 12px;
				padding: 20px;
				margin: 20px 0;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
				display: block;
				overflow-x: hidden;
				width: 100%;
				box-sizing: border-box;
			}

			.show-dialpad-button {
				text-align: center;
				margin-top: 15px;
			}

			.show-dialpad-button button {
				width: 100%;
				max-width: 200px;
			}

			#callNumber {
				text-align: center;
				font-size: 18px;
				margin-bottom: 10px;
				font-family: monospace;
				width: 100%;
				max-width: 100%;
				box-sizing: border-box;
				overflow-x: hidden;
			}

			.log {
				background: #f8f8f8;
				border-radius: 8px;
				padding: 15px;
				max-height: 400px;
				overflow-y: auto;
				font-family: monospace;
				font-size: 12px;
				color: #666;
			}

			.log-entry {
				margin-bottom: 5px;
				padding: 5px;
				background: white;
				border-radius: 4px;
			}

			.audio-container {
				display: none;
			}

			.incoming-call {
				display: none;
				background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
				color: white;
				padding: 20px;
				border-radius: 12px;
				margin-bottom: 20px;
				animation: pulse 1.5s infinite;
				overflow-x: hidden;
				width: 100%;
				box-sizing: border-box;
			}

			.incoming-call.active {
				display: block;
			}

			.incoming-caller {
				font-size: 20px;
				font-weight: bold;
				margin-bottom: 10px;
				text-align: center;
			}

			.incoming-number {
				font-size: 16px;
				margin-bottom: 15px;
				text-align: center;
				opacity: 0.9;
			}

			.incoming-buttons {
				display: flex;
				gap: 10px;
			}

			.btn-answer {
				background: white;
				color: #4caf50;
				flex: 1;
			}

			.btn-answer:hover {
				background: #f0f0f0;
			}

			.btn-decline {
				background: rgba(255, 255, 255, 0.2);
				color: white;
				flex: 1;
			}

			.btn-decline:hover {
				background: rgba(255, 255, 255, 0.3);
			}

			.storage-info {
				background: #e3f2fd;
				border: 1px solid #90caf9;
				border-radius: 8px;
				padding: 10px;
				margin-top: 10px;
				font-size: 12px;
				color: #1976d2;
			}

			.history-call {
				color: #667eea;
				text-decoration: none;
				cursor: pointer;
			}

			.history-call:hover {
				text-decoration: underline;
			}

			#ringingIndicator {
				display: none;
				font-size: 18px;
				color: #667eea;
				margin: 10px 0;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="header">
				<div class="header-buttons">
					<button
						class="header-toggle active"
						onclick="showPhone()"
						title="Phone"
					>
						üìû
					</button>
					<button
						class="header-toggle"
						onclick="showContacts()"
						title="Contacts"
					>
						üë•
					</button>
					<button
						class="header-toggle"
						onclick="showHistory()"
						title="Call History"
					>
						üìú
					</button>
					<button
						class="header-toggle"
						onclick="showLog()"
						title="Event Log"
					>
						üìã
					</button>
					<button
						class="header-toggle"
						onclick="showSettings()"
						title="Settings"
					>
						‚öôÔ∏è
					</button>
				</div>
				<h1>VoiceTel</h1>
				<div id="status" class="status">Disconnected</div>
			</div>

			<div class="content">
				<div class="section config-section" id="configSection">
					<h2>Settings</h2>

					<div class="button-group" style="margin-bottom: 20px">
						<button
							id="registerBtn"
							class="btn-primary"
							onclick="register()"
						>
							Register
						</button>
						<button
							id="unregisterBtn"
							class="btn-secondary"
							onclick="unregister()"
							disabled
						>
							Unregister
						</button>
					</div>
					<input
						type="hidden"
						id="sipServer"
						value="wss://tls.voicetel.com:443"
					/>

					<div class="form-group">
						<label>
							Username
							<small style="color: #999"
								>Must be exactly 10 digits (your phone
								number)</small
							>
						</label>
						<input
							type="tel"
							id="username"
							placeholder="e.g. 5551234567"
							maxlength="10"
							pattern="[0-9]{10}"
							required
							inputmode="numeric"
						/>
						<small
							id="usernameError"
							style="
								color: #d32f2f;
								display: none;
								margin-top: 5px;
							"
						>
							Username must be exactly 10 numeric digits
						</small>
					</div>

					<div class="form-group">
						<label>Password</label>
						<input
							type="password"
							id="password"
							placeholder="password"
						/>
					</div>

					<div class="form-group">
						<label>Display Name</label>
						<input
							type="text"
							id="displayName"
							placeholder="Your Name"
						/>
					</div>

					<div class="form-group">
						<label>
							Caller ID Number
							<small style="color: #999"
								>Optional - North American format only (10
								digits)</small
							>
						</label>
						<input
							type="tel"
							id="callerID"
							placeholder="e.g. 8005551234"
							maxlength="10"
							pattern="[2-9][0-9]{2}[2-9][0-9]{6}"
							inputmode="numeric"
						/>
						<small
							id="callerIDError"
							style="
								color: #d32f2f;
								display: none;
								margin-top: 5px;
							"
						>
							Please enter a valid 10-digit North American phone
							number
						</small>
					</div>

					<div
						class="form-group"
						style="
							background: #f8f8f8;
							padding: 15px;
							border-radius: 8px;
							margin-top: 20px;
						"
					>
						<label
							style="
								display: flex;
								align-items: center;
								cursor: pointer;
								color: #667eea;
								font-weight: 600;
							"
						>
							<input
								type="checkbox"
								id="saveCredentials"
								style="width: auto; margin-right: 8px"
							/>
							Save credentials
						</label>
						<small
							style="color: #999; display: block; margin-top: 8px"
						>
							üíæ Credentials are saved in local storage
						</small>

						<label
							style="
								display: flex;
								align-items: center;
								cursor: pointer;
								color: #667eea;
								font-weight: 600;
								margin-top: 20px;
							"
						>
							<input type="checkbox" id="registerOnStartup" />
							<span>Register automatically</span>
						</label>
						<small
							style="color: #999; display: block; margin-top: 8px"
						>
							ü§ñ Register automatically on startup
						</small>

						<label
							style="
								display: flex;
								align-items: center;
								cursor: pointer;
								color: #667eea;
								font-weight: 600;
								margin-top: 20px;
							"
						>
							<input type="checkbox" id="enableCallRecording" />
							<span>Enable call recording</span>
						</label>
						<small
							style="color: #999; display: block; margin-top: 8px"
						>
							üéôÔ∏è Record calls automatically when enabled
						</small>
						<div
							style="
								color: #ff6b6b;
								font-size: 12px;
								margin-top: 8px;
								padding: 8px;
								background-color: #fff5f5;
								border-left: 3px solid #ff6b6b;
								border-radius: 4px;
							"
						>
							‚ö†Ô∏è <strong>Legal Notice:</strong> Only enable call
							recording where it is legally permitted. Recording
							calls without consent may violate privacy laws in
							your jurisdiction. Always inform all parties before
							recording.
						</div>

						<label
							style="
								display: flex;
								align-items: center;
								cursor: pointer;
								color: #667eea;
								font-weight: 600;
								margin-top: 20px;
							"
						>
							<input type="checkbox" id="hideEventLog" />
							<span>Hide Event Log</span>
						</label>
						<small
							style="color: #999; display: block; margin-top: 8px"
						>
							üëÅÔ∏è Hide the event log from the main interface
						</small>

						<div
							class="storage-info"
							style="display: none"
							id="storageInfo"
						>
							Settings saved locally on this device
						</div>

						<button
							class="btn-secondary"
							onclick="clearAllData()"
							style="
								margin-top: 10px;
								padding: 8px 16px;
								font-size: 12px;
							"
						>
							Clear All Saved Data
						</button>
					</div>
				</div>

				<div class="section hideable" id="callSection">
					<div id="incomingCall" class="incoming-call">
						<div
							style="
								text-align: center;
								font-size: 32px;
								margin-bottom: 10px;
							"
						>
							üìû
						</div>
						<div class="incoming-caller" id="incomingCallerName">
							Incoming Call
						</div>
						<div class="incoming-number" id="incomingCallerNumber">
							Unknown Number
						</div>
						<div class="incoming-buttons">
							<button class="btn-answer" onclick="answerCall()">
								‚úî Answer
							</button>
							<button class="btn-decline" onclick="declineCall()">
								‚úó Decline
							</button>
						</div>
						<div
							style="
								text-align: center;
								margin-top: 10px;
								font-size: 11px;
								opacity: 0.8;
							"
						>
							Press Enter to answer ‚Ä¢ Escape to decline
						</div>
					</div>

					<div id="dialpadLayer" class="dialpad-layer">
						<div class="form-group">
							<input
								type="text"
								id="callNumber"
								placeholder="Enter number to dial / DTMF during call"
								inputmode="numeric"
							/>
						</div>

						<div class="dialpad">
							<button onclick="appendNumber('1')">1</button>
							<button onclick="appendNumber('2')">2</button>
							<button onclick="appendNumber('3')">3</button>
							<button onclick="appendNumber('4')">4</button>
							<button onclick="appendNumber('5')">5</button>
							<button onclick="appendNumber('6')">6</button>
							<button onclick="appendNumber('7')">7</button>
							<button onclick="appendNumber('8')">8</button>
							<button onclick="appendNumber('9')">9</button>
							<button onclick="appendNumber('*')">*</button>
							<button onclick="appendNumber('0')">0</button>
							<button onclick="appendNumber('#')">#</button>
						</div>

						<div class="form-group" style="margin-top: 15px">
							<label
								style="
									display: flex;
									align-items: center;
									cursor: pointer;
								"
							>
								<input
									type="checkbox"
									id="hideCallerID"
									style="width: auto; margin-right: 8px"
								/>
								Hide Caller ID (Privacy)
							</label>
						</div>

						<div class="button-group">
							<button
								id="callBtn"
								class="btn-success"
								onclick="makeCall()"
								disabled
							>
								üìû Call
							</button>
							<button
								class="btn-secondary"
								onclick="clearNumber()"
							>
								Clear
							</button>
						</div>
					</div>

					<div id="callControls" class="call-controls">
						<div class="call-info">
							<div id="callStatus">Call in progress</div>
							<div id="callDuration">00:00</div>
						</div>
						<div id="ringingIndicator">üîî Ringing...</div>
						<div
							class="button-group"
							style="max-width: 300px; margin: 0 auto"
						>
							<button
								id="muteBtn"
								class="btn-secondary"
								onclick="toggleMute()"
							>
								Mute
							</button>
							<button
								id="hangupBtn"
								class="btn-danger"
								onclick="hangup()"
							>
								Hang Up
							</button>
						</div>
						<div
							id="showDialpadBtn"
							class="show-dialpad-button"
							style="display: none"
						>
							<button
								class="btn-secondary"
								onclick="showDialpad()"
							>
								üì± Show Dialpad
							</button>
						</div>
					</div>
				</div>

				<div class="section log-section" id="logSection">
					<h2>Event Log</h2>
					<div id="log" class="log"></div>
					<div
						id="serverInfo"
						style="
							text-align: center;
							margin-top: 10px;
							color: #999;
							font-size: 12px;
						"
					>
						WebSocket: Loading... | SIP Domain: Loading...
					</div>

					<details
						style="
							margin-top: 15px;
							padding: 10px;
							background: #f8f8f8;
							border-radius: 8px;
						"
					>
						<summary
							style="
								cursor: pointer;
								color: #667eea;
								font-weight: 600;
							"
						>
							‚ö†Ô∏è Troubleshooting Tips
						</summary>
						<div
							style="
								margin-top: 10px;
								font-size: 13px;
								color: #666;
								line-height: 1.6;
							"
						>
							<ul style="margin-left: 20px">
								<li>
									Ensure microphone permissions are granted
								</li>
								<li>
									Try using Chrome or Firefox (latest
									versions)
								</li>
								<li>
									Check that your firewall allows WebRTC
									traffic
								</li>
								<li>Disable VPN if you're using one</li>
							</ul>
							<p style="margin-top: 10px">
								<strong
									>Need assistance? Contact the
									<a href="mailto:support@voicetel.com"
										>VoiceTel Support Team</a
									></strong
								>
							</p>
						</div>
					</details>
				</div>

				<div class="section log-section" id="contactsSection">
					<h2>Contacts</h2>
					<div class="contacts-search" style="margin-bottom: 15px">
						<input
							type="text"
							id="contactSearch"
							placeholder="üîç Search contacts..."
							class="input-field"
							style="
								width: 100%;
								padding: 12px 16px;
								border: 2px solid #e1e5e9;
								border-radius: 25px;
								font-size: 14px;
								background: #f8f9fa;
								transition: all 0.3s ease;
								outline: none;
							"
							onfocus="this.style.borderColor='#007bff'; this.style.backgroundColor='white'; this.style.boxShadow='0 0 0 3px rgba(0,123,255,0.1)';"
							onblur="this.style.borderColor='#e1e5e9'; this.style.backgroundColor='#f8f9fa'; this.style.boxShadow='none';"
						/>
					</div>
					<div id="contactsList" class="log">
						<div
							class="contact-item"
							style="
								text-align: center;
								padding: 20px;
								color: #666;
							"
						>
							<button
								class="btn-primary"
								onclick="loadContacts()"
							>
								üì± Load Contacts
							</button>
							<p style="margin-top: 10px; font-size: 14px">
								Tap to load your device contacts
							</p>
						</div>
					</div>
					<div class="contacts-actions">
						<button class="btn-secondary" onclick="loadContacts()">
							üîÑ Refresh
						</button>
						<button class="btn-secondary" onclick="clearContacts()">
							üóëÔ∏è Clear
						</button>
					</div>
				</div>

				<div class="section log-section" id="historySection">
					<h2>Call History</h2>
					<div id="callHistory" class="log"></div>
					<div class="history-actions">
						<button
							class="btn-secondary"
							onclick="renderCallHistory()"
						>
							üîÑ Refresh
						</button>
						<button class="btn-secondary" onclick="clearHistory()">
							üóëÔ∏è Clear History
						</button>
						<button
							class="btn-secondary"
							onclick="clearRecordings()"
						>
							üéôÔ∏è Clear Recordings
						</button>
					</div>
				</div>
			</div>

			<div class="audio-container">
				<audio id="remoteAudio" autoplay playsinline></audio>
				<audio id="localAudio" autoplay muted playsinline></audio>
			</div>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/sip.js@0.15.11/dist/sip.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
		<script>
			// Contacts plugin will be available via Capacitor at runtime
			// We'll access it through window.Capacitor.Plugins.Contacts
		</script>
		<script>
			// Capacitor will be available at runtime
			// We'll check for it in the app state listeners
			// Constants
			const INCOMING_CALL_TIMEOUT_MS = 30000;
			const DTMF_DURATION_MS = 250;
			const DTMF_INTERTONE_GAP_MS = 100;
			const SIP_REGISTRATION_EXPIRES_SEC = 180;
			const USERNAME_LENGTH = 10;
			const APP_VERSION = window.VOICETEL_VERSION || "3.5.6";
			const SIP_DOMAIN = window.VOICETEL_SIP_DOMAIN || "tls.voicetel.com";
			const SIP_SERVER =
				window.VOICETEL_SIP_SERVER || "wss://tls.voicetel.com:443";

			// Configure localforage
			localforage.config({
				name: "VoiceTel",
				storeName: "config",
			});

			// Simple Storage Manager
			const Storage = {
				CONFIG_KEY: "voicetel_config",
				HISTORY_KEY: "voicetel_history",

				async saveConfig() {
					try {
						const saveEnabled =
							document.getElementById("saveCredentials").checked;

						if (!saveEnabled) {
							await localforage.removeItem(this.CONFIG_KEY);
							return;
						}

						const config = {
							username: document.getElementById("username").value,
							password: document.getElementById("password").value,
							displayName:
								document.getElementById("displayName").value,
							callerID: document.getElementById("callerID").value,
							hideCallerID:
								document.getElementById("hideCallerID").checked,
							registerOnStartup:
								document.getElementById("registerOnStartup")
									.checked,
							hideEventLog:
								document.getElementById("hideEventLog").checked,
							enableCallRecording: document.getElementById(
								"enableCallRecording",
							).checked,
							saveCredentials: true,
						};

						await localforage.setItem(this.CONFIG_KEY, config);

						// Show saved indicator
						const info = document.getElementById("storageInfo");
						info.style.display = "block";
						setTimeout(() => {
							info.style.display = "none";
						}, 2000);

						log("Configuration saved locally");
					} catch (e) {
						console.error("Save failed:", e);
						log("Failed to save configuration");
					}
				},

				async loadConfig() {
					try {
						const config = await localforage.getItem(
							this.CONFIG_KEY,
						);

						if (!config) return;

						// Restore form fields
						if (config.username)
							document.getElementById("username").value =
								config.username;
						if (config.password)
							document.getElementById("password").value =
								config.password;
						if (config.displayName)
							document.getElementById("displayName").value =
								config.displayName;
						if (config.callerID)
							document.getElementById("callerID").value =
								config.callerID;

						// Restore checkboxes
						document.getElementById("hideCallerID").checked =
							config.hideCallerID || false;
						document.getElementById("registerOnStartup").checked =
							config.registerOnStartup || false;
						document.getElementById("hideEventLog").checked =
							config.hideEventLog || false;
						document.getElementById("enableCallRecording").checked =
							config.enableCallRecording || false;
						document.getElementById("saveCredentials").checked =
							config.saveCredentials || false;

						log("Configuration loaded from local storage");
						console.log(
							"hideEventLog setting loaded:",
							config.hideEventLog,
						);
						console.log(
							"hideEventLog checkbox checked:",
							document.getElementById("hideEventLog").checked,
						);

						// Update event log visibility based on setting
						updateEventLogVisibility();

						// Auto-register if enabled
						if (
							config.registerOnStartup &&
							config.username &&
							config.password
						) {
							setTimeout(() => {
								log("Auto-registering...");
								register();
							}, 500);
						}
					} catch (e) {
						console.error("Load failed:", e);
					}
				},

				async clearAll() {
					await localforage.removeItem(this.CONFIG_KEY);
					await localforage.removeItem(this.HISTORY_KEY);
					log("All saved data cleared");
				},

				async addCallToHistory(
					type,
					number,
					duration,
					recording = null,
				) {
					try {
						const history =
							(await localforage.getItem(this.HISTORY_KEY)) || [];
						history.unshift({
							type,
							number,
							duration,
							timestamp: new Date().toISOString(),
							recording: recording || null, // Store recording filename if available
						});

						// Keep last 100 calls
						if (history.length > 100) {
							history.length = 100;
						}

						await localforage.setItem(this.HISTORY_KEY, history);
					} catch (e) {
						console.error("History save failed:", e);
					}
				},

				async updateCallHistoryWithRecording(filename) {
					try {
						const history = await this.getHistory();
						// Find the most recent call entry (first in array) and add recording filename
						if (history.length > 0 && !history[0].recording) {
							history[0].recording = filename;
							await localforage.setItem(
								this.HISTORY_KEY,
								history,
							);
							log(`Recording ${filename} linked to call history`);
						}
					} catch (e) {
						console.error(
							"Failed to update call history with recording:",
							e,
						);
					}
				},

				async getHistory() {
					return (await localforage.getItem(this.HISTORY_KEY)) || [];
				},

				async clearHistory() {
					await localforage.removeItem(this.HISTORY_KEY);
				},

				async addRecordingToHistory(recording) {
					try {
						const RECORDINGS_KEY = "voicetel_recordings";
						const recordings =
							(await localforage.getItem(RECORDINGS_KEY)) || [];
						recordings.unshift(recording);

						// Keep last 50 recordings
						if (recordings.length > 50) {
							recordings.length = 50;
						}

						await localforage.setItem(RECORDINGS_KEY, recordings);
					} catch (e) {
						console.error("Recording metadata save failed:", e);
					}
				},

				async getRecordings() {
					const RECORDINGS_KEY = "voicetel_recordings";
					return (await localforage.getItem(RECORDINGS_KEY)) || [];
				},

				async clearRecordings() {
					const RECORDINGS_KEY = "voicetel_recordings";
					await localforage.removeItem(RECORDINGS_KEY);
				},
			};

			// Global variables for SIP
			let registeredUsername = null;
			let userAgent = null;
			let currentSession = null;
			let incomingSession = null;
			let incomingCallTimeout = null;
			let isRegistered = false;
			let isMuted = false;
			let callTimer = null;
			let callStartTime = null;
			let ringingAudio = null;
			let registrationPromise = null; // Single registration promise to prevent concurrent registrations
			let unregistrationPromise = null; // Track unregistration in progress
			let reRegisterTimeout = null; // Debounce re-registration
			let activeCall = false; // Global flag to track if there's an active call
			let isRecording = false;
			let mediaRecorder = null;
			let recordedChunks = [];
			let recordingStream = null;
			let recordingAudioContext = null;
			let recordingDestination = null;
			let recordingCallStartTime = null; // Store call start time for recording metadata
			let recordingCallerNumber = null; // Store caller number for recording metadata
			let recordingCallDirection = null; // Store call direction for recording metadata
			let currentRecordingFilename = null; // Store filename for linking to call history

			// Bluetooth audio management
			let bluetoothAudioContext = null;
			let bluetoothAudioGain = null;

			// Event listener cleanup tracking
			let activeEventListeners = new Set();
			let webSocketMessageHandler = null;

			// Call tracking for history
			let __callDirection = null;
			let __answeredIncoming = false;
			let __originalCallNumber = null; // Store original number for call history
			let __incomingRaw = null;
			let __incomingDisplay = null;

			// Username validation
			function isValidUsername(username) {
				return (
					username &&
					/^\d{10}$/.test(username) &&
					username.length === USERNAME_LENGTH
				);
			}

			function validateNorthAmericanNumber(number) {
				const cleaned = number.replace(/\D/g, "");
				if (cleaned.length !== USERNAME_LENGTH) return false;
				const npaFirstDigit = parseInt(cleaned[0]);
				const nxxFirstDigit = parseInt(cleaned[3]);
				return (
					npaFirstDigit >= 2 &&
					npaFirstDigit <= 9 &&
					nxxFirstDigit >= 2 &&
					nxxFirstDigit <= 9
				);
			}

			// Ringing tone generation
			function createRingingTone() {
				const audioContext = new (window.AudioContext ||
					window.webkitAudioContext)();

				// iOS: Resume AudioContext if suspended (required for iOS)
				if (audioContext.state === "suspended") {
					audioContext.resume().catch((err) => {
						console.error("Failed to resume AudioContext:", err);
					});
				}

				const oscillator1 = audioContext.createOscillator();
				const oscillator2 = audioContext.createOscillator();
				const gainNode = audioContext.createGain();

				oscillator1.frequency.value = 440;
				oscillator2.frequency.value = 480;
				oscillator1.type = "sine";
				oscillator2.type = "sine";

				gainNode.gain.setValueAtTime(0, audioContext.currentTime);

				const ringPattern = () => {
					const now = audioContext.currentTime;
					gainNode.gain.setValueAtTime(0.1, now);
					gainNode.gain.setValueAtTime(0.1, now + 2);
					gainNode.gain.setValueAtTime(0, now + 2.01);
					gainNode.gain.setValueAtTime(0, now + 6);
				};

				oscillator1.connect(gainNode);
				oscillator2.connect(gainNode);
				gainNode.connect(audioContext.destination);

				oscillator1.start();
				oscillator2.start();

				ringPattern();
				const ringInterval = setInterval(ringPattern, 6000);

				return {
					stop: () => {
						clearInterval(ringInterval);
						gainNode.gain.setValueAtTime(
							0,
							audioContext.currentTime,
						);
						setTimeout(() => {
							oscillator1.stop();
							oscillator2.stop();
							audioContext.close();
						}, 100);
					},
				};
			}

			function startRinging() {
				document.getElementById("ringingIndicator").style.display =
					"block";
				document.getElementById("callStatus").textContent =
					"Ringing...";

				try {
					ringingAudio = createRingingTone();
				} catch (e) {
					log("Could not generate ringing tone: " + e.message);
				}
			}

			function stopRinging() {
				document.getElementById("ringingIndicator").style.display =
					"none";
				document.getElementById("callStatus").textContent =
					"Call in progress";

				if (ringingAudio) {
					ringingAudio.stop();
					ringingAudio = null;
				}
			}

			// Logging function
			function log(message) {
				// Log to console for logcat capture
				console.log(message);

				const logDiv = document.getElementById("log");
				const entry = document.createElement("div");
				entry.className = "log-entry";
				const timestamp = new Date().toLocaleTimeString();
				entry.textContent = `[${timestamp}] ${message}`;
				logDiv.insertBefore(entry, logDiv.firstChild);

				while (logDiv.children.length > 10) {
					logDiv.removeChild(logDiv.lastChild);
				}
			}

			function updateStatus(text, registered = false) {
				const statusEl = document.getElementById("status");
				statusEl.textContent = text;
				if (registered) {
					statusEl.classList.add("registered");
				} else {
					statusEl.classList.remove("registered");
				}
			}

			// SIP Registration
			async function register() {
				if (typeof SIP === "undefined") {
					alert(
						"SIP.js library is not loaded. Please refresh the page.",
					);
					log("Error: SIP.js library not available");
					return;
				}

				// If registration is already in progress, return the existing promise
				if (registrationPromise) {
					log(
						"Registration already in progress - waiting for completion",
					);
					return registrationPromise;
				}

				// If currently unregistering, wait for it to complete first
				if (unregistrationPromise) {
					log(
						"Unregistration in progress - waiting for completion before registering",
					);
					try {
						await unregistrationPromise;
					} catch (error) {
						log(
							`Error waiting for unregistration: ${error.message}`,
						);
					}
				}

				const server = document.getElementById("sipServer").value;
				const username = document.getElementById("username").value;
				const password = document.getElementById("password").value;
				const displayName =
					document.getElementById("displayName").value || username;
				const callerID = document.getElementById("callerID").value;

				if (!server || !username || !password) {
					alert("Please fill in all required fields");
					return Promise.reject(new Error("Missing required fields"));
				}

				if (!isValidUsername(username)) {
					alert("Username must be exactly 10 numeric digits");
					document.getElementById("usernameError").style.display =
						"block";
					return Promise.reject(new Error("Invalid username"));
				}

				// Create and store the registration promise
				registrationPromise = new Promise((resolve, reject) => {
					registeredUsername = username;

					log("Starting registration...");
					log(`Connecting to VoiceTel server (${SIP_DOMAIN})...`);

					const uri = `sip:${username}@${SIP_DOMAIN}`;

					const transportOptions = {
						wsServers: [server],
						traceSip: true,
						wsServerMaxReconnectionAttempts: 0,
						wsServerReconnectionTimeout: 0,
					};

					const userAgentOptions = {
						uri: uri,
						transportOptions: transportOptions,
						authorizationUser: username,
						password: password,
						displayName: displayName,
						userAgentString: `VoiceTel/${APP_VERSION}`,
						register: true,
						registerOptions: {
							registrar: `sip:${SIP_DOMAIN}`,
							expires: SIP_REGISTRATION_EXPIRES_SEC,
						},
						sessionDescriptionHandlerFactoryOptions: {
							constraints: {
								audio: true,
								video: false,
							},
							peerConnectionOptions: {
								rtcConfiguration: {
									iceServers: [
										{
											urls: "stun:stun.l.google.com:19302",
										},
										{
											urls: "stun:stun1.l.google.com:19302",
										},
									],
								},
							},
						},
						hackWssInTransport: false,
						hackIpInContact: true,
						dtmfType: "rtp",
					};

					try {
						userAgent = new SIP.UA(userAgentOptions);

						// Set up one-time event handlers for this registration attempt
						const onRegistered = () => {
							isRegistered = true;
							registrationPromise = null; // Clear promise on success
							updateStatus("Registered", true);
							log("Successfully registered");
							log("SIP/2.0 200 OK");

							document.getElementById("registerBtn").disabled =
								true;
							document.getElementById("unregisterBtn").disabled =
								false;
							document.getElementById("callBtn").disabled = false;

							if (
								"Notification" in window &&
								Notification.permission === "default"
							) {
								Notification.requestPermission().then(
									(permission) => {
										if (permission === "granted") {
											log(
												"Desktop notifications enabled for incoming calls",
											);
										}
									},
								);
							}

							// Remove one-time handlers
							userAgent.off("registered", onRegistered);
							userAgent.off(
								"registrationFailed",
								onRegistrationFailed,
							);

							resolve();
						};

						const onRegistrationFailed = (response, cause) => {
							registrationPromise = null; // Clear promise on failure
							isRegistered = false;

							if (
								response &&
								response.status_code &&
								response.reason_phrase
							) {
								log(
									`SIP/2.0 ${response.status_code} ${response.reason_phrase}`,
								);
							}
							log(`Registration failed: ${cause}`);
							updateStatus("Registration Failed");

							// Remove one-time handlers
							userAgent.off("registered", onRegistered);
							userAgent.off(
								"registrationFailed",
								onRegistrationFailed,
							);

							// Clean up userAgent on failure
							if (userAgent) {
								try {
									userAgent.stop();
								} catch (e) {
									log(
										`Error stopping userAgent: ${e.message}`,
									);
								}
								userAgent = null;
							}

							reject(new Error(`Registration failed: ${cause}`));
						};

						// Attach one-time handlers
						userAgent.once("registered", onRegistered);
						userAgent.once(
							"registrationFailed",
							onRegistrationFailed,
						);

						// Set up persistent event handlers (not one-time)
						userAgent.on("unregistered", () => {
							log("SIP/2.0 200 OK (Unregistered)");
						});

						userAgent.on("invite", (session) => {
							const callerInfo =
								session.remoteIdentity.displayName ||
								session.remoteIdentity.uri.user;
							log(`Incoming call from ${callerInfo}`);

							if (
								"Notification" in window &&
								Notification.permission === "granted"
							) {
								new Notification("VoiceTel Phone", {
									body: `Incoming call from ${callerInfo}`,
									icon: "üìû",
									requireInteraction: true,
								});
							}

							handleIncomingCall(session);
						});

						userAgent.start();
					} catch (error) {
						registrationPromise = null; // Clear promise on error
						log(`Registration failed: ${error.message}`);
						updateStatus("Registration Failed");
						console.error(error);
						reject(error);
					}
				});

				return registrationPromise;
			}

			async function unregister() {
				// If unregistration already in progress, return the existing promise
				if (unregistrationPromise) {
					log(
						"Unregistration already in progress - waiting for completion",
					);
					return unregistrationPromise;
				}

				// If registration is in progress, wait for it to complete first
				if (registrationPromise) {
					log(
						"Registration in progress - waiting for completion before unregistering",
					);
					try {
						await registrationPromise;
					} catch (error) {
						// Continue with unregistration even if registration failed
						log(
							`Registration completed with error: ${error.message}`,
						);
					}
				}

				unregistrationPromise = new Promise((resolve, reject) => {
					try {
						// Clean up WebSocket event listeners
						if (
							userAgent &&
							userAgent.transport &&
							userAgent.transport.ws &&
							webSocketMessageHandler
						) {
							userAgent.transport.ws.removeEventListener(
								"message",
								webSocketMessageHandler,
							);
							webSocketMessageHandler = null;
						}

						if (userAgent) {
							userAgent.unregister();
							userAgent.stop();
							userAgent = null;
						}

						isRegistered = false;
						registeredUsername = null;
						unregistrationPromise = null; // Clear promise on success
						updateStatus("Disconnected");
						log("Unregistered successfully");

						document.getElementById("registerBtn").disabled = false;
						document.getElementById("unregisterBtn").disabled =
							true;
						document.getElementById("callBtn").disabled = true;

						resolve();
					} catch (error) {
						unregistrationPromise = null; // Clear promise on error
						log(`Unregister failed: ${error.message}`);
						console.error(error);
						reject(error);
					}
				});

				return unregistrationPromise;
			}

			// Make outgoing call
			function makeCall() {
				let number = document.getElementById("callNumber").value;
				const originalNumber = number;
				number = number.replace(/\D/g, "");

				if (originalNumber !== number && originalNumber.length > 0) {
					log(`Sanitized number: "${originalNumber}" ‚Üí "${number}"`);
				}

				if (!number) {
					alert("Please enter a number to call");
					return;
				}

				if (!isRegistered || !userAgent) {
					alert("Please register first");
					return;
				}

				if (incomingSession) {
					alert("Please answer or decline the incoming call first");
					return;
				}

				const callerID = document
					.getElementById("callerID")
					.value.replace(/\D/g, "");
				if (callerID && !validateNorthAmericanNumber(callerID)) {
					alert(
						"Please enter a valid 10-digit North American phone number for Caller ID",
					);
					document.getElementById("callerIDError").style.display =
						"block";
					return;
				}

				try {
					const displayName =
						document.getElementById("displayName").value ||
						registeredUsername;
					const hideCallerID =
						document.getElementById("hideCallerID").checked;

					const domain = SIP_DOMAIN;
					const uri = `sip:${number}@${domain}`;

					const options = {
						sessionDescriptionHandlerOptions: {
							constraints: {
								audio: true,
								video: false,
							},
						},
					};

					options.extraHeaders = [];

					let pAssertedIdentity;
					if (callerID && validateNorthAmericanNumber(callerID)) {
						const formattedNumber = "+1" + callerID;
						pAssertedIdentity = `"${displayName}" <sip:${formattedNumber}@${SIP_DOMAIN}>`;
						log(
							`Setting caller ID: ${displayName} ${formattedNumber}`,
						);
					} else {
						pAssertedIdentity = `"${displayName}" <sip:${registeredUsername}@${SIP_DOMAIN}>`;
						log(
							`Using default caller ID: ${displayName} ${registeredUsername}`,
						);
					}

					options.extraHeaders.push(
						"P-Asserted-Identity: " + pAssertedIdentity,
					);
					options.extraHeaders.push(
						"P-Preferred-Identity: " + pAssertedIdentity,
					);

					if (hideCallerID) {
						options.extraHeaders.push("Privacy: id");
						log("Caller ID privacy enabled");
					} else {
						options.extraHeaders.push("Privacy: none");
					}

					currentSession = userAgent.invite(uri, options);
					__callDirection = "outgoing";
					__originalCallNumber = number; // Store original number for call history

					// WebSocket progress sniff for ringing parity
					let sessionRingingStarted = false;
					if (currentSession.request) {
						const callId = currentSession.request.callId;
						webSocketMessageHandler = function (e) {
							if (e && e.data && e.data.includes(callId)) {
								const lines = e.data.split("\r\n");
								for (let line of lines) {
									if (line.startsWith("SIP/2.0")) {
										log(line);
										if (
											!sessionRingingStarted &&
											(line.includes("180 Ringing") ||
												line.includes(
													"183 Session Progress",
												))
										) {
											startRinging();
											sessionRingingStarted = true;
										}
										if (
											sessionRingingStarted &&
											line.includes("200 OK")
										) {
											stopRinging();
											sessionRingingStarted = false;
										}
										break;
									}
								}
							}
						};
						if (userAgent.transport && userAgent.transport.ws) {
							userAgent.transport.ws.addEventListener(
								"message",
								webSocketMessageHandler,
							);
							currentSession.on("terminated", () => {
								if (sessionRingingStarted) {
									stopRinging();
									sessionRingingStarted = false;
								}
								if (
									userAgent.transport &&
									userAgent.transport.ws &&
									webSocketMessageHandler
								) {
									userAgent.transport.ws.removeEventListener(
										"message",
										webSocketMessageHandler,
									);
									webSocketMessageHandler = null;
								}
							});
							currentSession.on("failed", () => {
								if (sessionRingingStarted) {
									stopRinging();
									sessionRingingStarted = false;
								}
								if (
									userAgent.transport &&
									userAgent.transport.ws &&
									webSocketMessageHandler
								) {
									userAgent.transport.ws.removeEventListener(
										"message",
										webSocketMessageHandler,
									);
									webSocketMessageHandler = null;
								}
							});
						}
					}

					setupSessionHandlers(currentSession);

					log(`Calling ${number}...`);
					log("SIP INVITE sent");
					showCallControls();
				} catch (error) {
					log(`Call failed: ${error.message}`);
					console.error(error);
					// Clean up on error - clear currentSession if it was set
					if (currentSession) {
						currentSession = null;
						hideCallControls();
					}
				}
			}

			// Handle incoming call
			function handleIncomingCall(session) {
				__incomingRaw = null;
				__incomingDisplay = null;

				if (currentSession) {
					log("Auto-rejecting incoming call - already in a call");
					session.reject();
					log("SIP/2.0 486 Busy Here");
					return;
				}

				incomingSession = session;
				log("SIP INVITE received");

				const callerUri =
					session.remoteIdentity &&
					session.remoteIdentity.uri &&
					session.remoteIdentity.uri.user
						? session.remoteIdentity.uri.user
						: "Unknown";
				__incomingRaw = callerUri;
				const callerName =
					session.remoteIdentity.displayName || "Unknown";

				let formattedNumber = callerUri;
				if (/^\d{10}$/.test(callerUri)) {
					formattedNumber = `(${callerUri.slice(0, 3)}) ${callerUri.slice(3, 6)}-${callerUri.slice(6)}`;
				} else if (/^\+1\d{10}$/.test(callerUri)) {
					const num = callerUri.slice(2);
					formattedNumber = `+1 (${num.slice(0, 3)}) ${num.slice(3, 6)}-${num.slice(6)}`;
				}

				document.getElementById("incomingCallerName").textContent =
					callerName;
				document.getElementById("incomingCallerNumber").textContent =
					formattedNumber;
				__incomingDisplay = formattedNumber;

				document.getElementById("incomingCall").classList.add("active");
				hideDialpad();
				startRinging();
				log("SIP/2.0 180 Ringing");

				log("SIP INVITE received - awaiting answer");
				log(`Incoming call from ${callerName} ${formattedNumber}`);
				log("Press Enter to answer or Escape to decline");

				// Show incoming call notification (Android)
				// Don't await - fire and forget to avoid blocking the call handling
				showIncomingCallNotification(callerName, formattedNumber).catch(
					(err) => {
						log(
							"Error in showIncomingCallNotification: " +
								err.message,
						);
						console.error("Notification error:", err);
					},
				);

				incomingCallTimeout = setTimeout(() => {
					if (incomingSession) {
						log("Auto-declining unanswered call after 30 seconds");
						declineCall();
					}
				}, INCOMING_CALL_TIMEOUT_MS);

				setupIncomingSessionHandlers(session);
			}

			function setupIncomingSessionHandlers(session) {
				// Track if this incoming call was answered
				let wasAnswered = false;

				session.on("terminated", () => {
					if (incomingCallTimeout) {
						clearTimeout(incomingCallTimeout);
						incomingCallTimeout = null;
					}
					hideIncomingCallUI();
					dismissIncomingCallNotification();

					// Only add "missed" if it was NOT answered and NOT manually declined
					if (!wasAnswered && !session.__declinedByUser) {
						log("Incoming call ended by caller (missed)");
						const num =
							__incomingRaw && __incomingRaw !== "Unknown"
								? __incomingRaw
								: __incomingDisplay || "Unknown";
						Storage.addCallToHistory("missed", num, "00:00");
					}

					incomingSession = null;
				});

				session.on("failed", () => {
					if (incomingCallTimeout) {
						clearTimeout(incomingCallTimeout);
						incomingCallTimeout = null;
					}
					hideIncomingCallUI();
					dismissIncomingCallNotification();
					log("Incoming call failed");
					incomingSession = null;
				});

				session.on("rejected", () => {
					if (incomingCallTimeout) {
						clearTimeout(incomingCallTimeout);
						incomingCallTimeout = null;
					}
					hideIncomingCallUI();
					dismissIncomingCallNotification();
					log("Incoming call was rejected");
					incomingSession = null;
				});

				// Mark as answered when accepted
				session.on("accepted", () => {
					wasAnswered = true;
				});
			}

			function answerCall() {
				if (!incomingSession) {
					log("No incoming call to answer");
					return;
				}

				if (incomingCallTimeout) {
					clearTimeout(incomingCallTimeout);
					incomingCallTimeout = null;
				}

				// Report call as connected to stop CallKit ringtone
				// Don't await - fire and forget to avoid blocking
				reportCallConnected().catch((err) => {
					console.error("Error reporting call connected:", err);
				});

				// Transfer session to current and mark as answered
				currentSession = incomingSession;
				incomingSession = null; // Clear incoming reference IMMEDIATELY
				__callDirection = "incoming";
				__answeredIncoming = true;
				activeCall = true;

				hideIncomingCallUI();
				setupSessionHandlers(currentSession);
				currentSession.accept();
				showCallControls();
				log("Call answered");
				log("SIP/2.0 200 OK");
			}

			function declineCall() {
				if (!incomingSession) {
					log("No incoming call to decline");
					return;
				}

				if (incomingCallTimeout) {
					clearTimeout(incomingCallTimeout);
					incomingCallTimeout = null;
				}

				// Stop ringing
				stopRinging();

				// Dismiss incoming call notification
				dismissIncomingCallNotification();

				// Record as declined (this is correct for a manual press)
				const num =
					__incomingRaw && __incomingRaw !== "Unknown"
						? __incomingRaw
						: __incomingDisplay ||
							document.getElementById("incomingCallerNumber")
								.textContent ||
							"Unknown";
				Storage.addCallToHistory("declined", num, "00:00");

				// mark this specific incoming session as manually declined
				incomingSession.__declinedByUser = true;

				// Send busy
				log("Sending SIP 486 Busy Here response...");
				incomingSession.reject({
					statusCode: 486,
					reasonPhrase: "Busy Here",
				});
				log("SIP reject(486) called on incomingSession");

				hideIncomingCallUI();
				log("Call declined");
				log("SIP/2.0 486 Busy Here");
				incomingSession = null;
			}

			function hideIncomingCallUI() {
				document
					.getElementById("incomingCall")
					.classList.remove("active");
				document.getElementById("incomingCallerName").textContent =
					"Incoming Call";
				document.getElementById("incomingCallerNumber").textContent =
					"Unknown Number";
				showDialpad();
			}

			function setupSessionHandlers(session) {
				if (!session || typeof session.on !== "function") {
					log("Session does not support event listeners");
					return;
				}

				// Per-session ringing guard (desktop parity)
				let ringingStarted = (function () {
					const el = document.getElementById("ringingIndicator");
					return !!(el && el.style.display === "block");
				})();

				session.on("response", (response) => {
					if (
						response &&
						response.status_code &&
						response.reason_phrase
					) {
						log(
							`SIP/2.0 ${response.status_code} ${response.reason_phrase}`,
						);
						// Manage ringing via response events
						if (
							!ringingStarted &&
							(response.status_code === 180 ||
								response.status_code === 183)
						) {
							startRinging();
							ringingStarted = true;
						}
						if (response.status_code === 200 && ringingStarted) {
							stopRinging();
							ringingStarted = false;
						}
					}
				});

				session.on("progress", (response) => {
					if (
						response &&
						response.status_code &&
						response.reason_phrase
					) {
						log(
							`SIP/2.0 ${response.status_code} ${response.reason_phrase}`,
						);
						if (
							!ringingStarted &&
							(response.status_code === 180 ||
								response.status_code === 183)
						) {
							startRinging();
							ringingStarted = true;
						}
						if (response.status_code === 183) {
							const remoteAudio =
								document.getElementById("remoteAudio");
							if (remoteAudio) {
								remoteAudio.volume = 0;
								log("Early media muted during ringing");
							}
						}
					}
				});

				session.on("terminated", (message, cause) => {
					if (ringingStarted) {
						stopRinging();
						ringingStarted = false;
					}
					log("Call ended" + (cause ? ": " + cause : ""));
					endCall();
				});

				session.on("failed", (response, cause) => {
					if (
						response &&
						response.status_code &&
						response.reason_phrase
					) {
						log(
							`SIP/2.0 ${response.status_code} ${response.reason_phrase}`,
						);
					}

					if (
						cause &&
						cause.includes("SESSION_DESCRIPTION_HANDLER_ERROR")
					) {
						log(
							"‚ö†Ô∏è Media negotiation failed - incompatible media format",
						);
						alert(
							"Call failed: Media format incompatibility.\nContact VoiceTel support for WebRTC configuration.",
						);
					} else {
						log("Call failed: " + (cause || "Unknown error"));
					}
					if (ringingStarted) {
						stopRinging();
						ringingStarted = false;
					}
					endCall();
				});

				session.on("rejected", (response, cause) => {
					if (
						response &&
						response.status_code &&
						response.reason_phrase
					) {
						log(
							`SIP/2.0 ${response.status_code} ${response.reason_phrase}`,
						);
					}
					log("Call rejected" + (cause ? ": " + cause : ""));
					if (ringingStarted) {
						stopRinging();
						ringingStarted = false;
					}
					endCall();
				});

				session.on("bye", (request) => {
					log("SIP BYE received");
					log("Call ended by remote");
					if (ringingStarted) {
						stopRinging();
						ringingStarted = false;
					}
					endCall();
				});

				session.on("accepted", (response) => {
					if (
						response &&
						response.status_code &&
						response.reason_phrase
					) {
						log(
							`SIP/2.0 ${response.status_code} ${response.reason_phrase}`,
						);
					}

					if (ringingStarted) {
						stopRinging();
						ringingStarted = false;
					}
					activeCall = true;
					log("Call connected");

					// Handle Bluetooth audio routing
					handleBluetoothAudio();

					// Configure audio session for lock screen continuity
					configureAudioSession();

					// Auto-start recording if enabled (only when call is answered/connected)
					const recordingEnabled =
						document.getElementById("enableCallRecording")
							?.checked || false;
					if (
						recordingEnabled &&
						activeCall &&
						session === currentSession
					) {
						// Wait a bit for audio tracks to be fully ready after call is answered
						setTimeout(async () => {
							// Double-check call is still active before starting recording
							if (
								activeCall &&
								currentSession &&
								currentSession === session
							) {
								await startRecording();
							}
						}, 500); // Small delay to ensure audio tracks are ready
					}

					if (
						currentSession &&
						currentSession.sessionDescriptionHandler &&
						currentSession.sessionDescriptionHandler.peerConnection
					) {
						const pc =
							currentSession.sessionDescriptionHandler
								.peerConnection;
						const remoteDesc = pc.remoteDescription;
						if (remoteDesc && remoteDesc.sdp) {
							if (remoteDesc.sdp.includes("telephone-event")) {
								log("Remote supports RFC 2833 telephone-event");
							} else {
								log(
									"‚ö†Ô∏è Remote does NOT support telephone-event - will use SIP INFO for DTMF",
								);
							}
						}
					}

					document.getElementById("callNumber").value = "";
					document.getElementById("callNumber").placeholder =
						"Type or press dialpad for DTMF";
					document.getElementById("callNumber").focus();
					startCallTimer();

					// On iOS, wait for CallKit audio session activation before playing audio
					const isIOS = window.Capacitor?.getPlatform() === 'ios';
					if (isIOS && !callKitAudioSessionActive) {
						log("‚è≥ [CallKit] Waiting for audio session activation...");
						pendingAudioStart = true;
					} else {
						try {
							const pc =
								session.sessionDescriptionHandler.peerConnection;
							const remoteStream = new MediaStream();
							pc.getReceivers().forEach((receiver) => {
								if (receiver.track) {
									remoteStream.addTrack(receiver.track);
								}
							});

							const remoteAudio =
								document.getElementById("remoteAudio");
							remoteAudio.srcObject = remoteStream;
							remoteAudio.volume = 1.0;
							remoteAudio.muted = false;
							remoteAudio.play().catch((err) => {
								log("Error playing remote audio: " + err.message);
							});
						} catch (e) {
							log("Error setting up audio: " + e.message);
						}
					}
				});

				session.on("trackAdded", () => {
					const isIOS = window.Capacitor?.getPlatform() === 'ios';
					
					// Early media muting while ringing (desktop parity)
					if (ringingStarted) {
						try {
							const pc =
								session.sessionDescriptionHandler.peerConnection;
							const remoteStream = new MediaStream();
							pc.getReceivers().forEach((receiver) => {
								if (receiver.track) {
									remoteStream.addTrack(receiver.track);
								}
							});

							const remoteAudio =
								document.getElementById("remoteAudio");
							remoteAudio.srcObject = remoteStream;
							remoteAudio.volume = 0;
							log("Early media audio track muted");
						} catch (e) {
							log("Error handling early media track: " + e.message);
						}
					} else if (activeCall) {
						// Call is active - ensure audio is playing
						if (isIOS && !callKitAudioSessionActive) {
							log("‚è≥ [CallKit] Waiting for audio session activation in trackAdded...");
							pendingAudioStart = true;
						} else {
							try {
								const pc =
									session.sessionDescriptionHandler.peerConnection;
								const remoteStream = new MediaStream();
								pc.getReceivers().forEach((receiver) => {
									if (receiver.track) {
										remoteStream.addTrack(receiver.track);
									}
								});

								const remoteAudio =
									document.getElementById("remoteAudio");
								remoteAudio.srcObject = remoteStream;
								remoteAudio.volume = 1.0;
								remoteAudio.muted = false;
								remoteAudio.play().catch((err) => {
									log("Error playing remote audio in trackAdded: " + err.message);
								});
							} catch (e) {
								log("Error handling track: " + e.message);
							}
						}
					}
				});
			}

			function hangup() {
				if (currentSession) {
					if (currentSession.hasAnswer) {
						currentSession.bye();
						log("SIP BYE sent");
					} else {
						currentSession.cancel();
						log("SIP CANCEL sent");
					}
					log("Hanging up...");
				}
			}

			function toggleMute() {
				if (
					!currentSession ||
					!currentSession.sessionDescriptionHandler
				)
					return;

				const pc =
					currentSession.sessionDescriptionHandler.peerConnection;
				const senders = pc.getSenders();

				senders.forEach((sender) => {
					if (sender.track && sender.track.kind === "audio") {
						sender.track.enabled = isMuted;
					}
				});

				isMuted = !isMuted;
				document.getElementById("muteBtn").textContent = isMuted
					? "Unmute"
					: "Mute";
				log(isMuted ? "Muted" : "Unmuted");
			}

			/**
			 * Start call recording using MediaRecorder API
			 * - iOS: Uses audio/mp4 (M4A) format with AAC codec for native compatibility
			 * - Android: Falls back to audio/webm with opus codec
			 * - Recordings are saved to native filesystem via Capacitor plugins
			 */
			async function startRecording() {
				if (isRecording) {
					log("Recording already in progress");
					return;
				}

				// Check if recording is enabled in settings
				const recordingEnabled =
					document.getElementById("enableCallRecording")?.checked ||
					false;
				if (!recordingEnabled) {
					log("Call recording is disabled in settings");
					return;
				}

				try {
					const pc =
						currentSession.sessionDescriptionHandler.peerConnection;

					if (!pc) {
						throw new Error("PeerConnection not available");
					}

					log("Checking audio tracks...");

					// Create audio context for mixing
					recordingAudioContext = new (window.AudioContext ||
						window.webkitAudioContext)();
					recordingDestination =
						recordingAudioContext.createMediaStreamDestination();
					recordingStream = recordingDestination.stream;

					let tracksAdded = 0;

					// Get remote audio tracks (what we hear)
					const receivers = pc.getReceivers();
					log(`Found ${receivers.length} receivers`);
					receivers.forEach((receiver, idx) => {
						if (receiver.track && receiver.track.kind === "audio") {
							log(
								`Adding remote audio track ${idx}: ${receiver.track.id}, enabled: ${receiver.track.enabled}, muted: ${receiver.track.muted}`,
							);
							try {
								const remoteSource =
									recordingAudioContext.createMediaStreamSource(
										new MediaStream([receiver.track]),
									);
								remoteSource.connect(recordingDestination);
								tracksAdded++;
							} catch (e) {
								log(
									`Failed to add remote track ${idx}: ${e.message}`,
								);
								console.error("Remote track error:", e);
							}
						}
					});

					// Get local audio tracks (what we say)
					const senders = pc.getSenders();
					log(`Found ${senders.length} senders`);
					senders.forEach((sender, idx) => {
						if (sender.track && sender.track.kind === "audio") {
							log(
								`Adding local audio track ${idx}: ${sender.track.id}, enabled: ${sender.track.enabled}, muted: ${sender.track.muted}`,
							);
							try {
								const localSource =
									recordingAudioContext.createMediaStreamSource(
										new MediaStream([sender.track]),
									);
								localSource.connect(recordingDestination);
								tracksAdded++;
							} catch (e) {
								log(
									`Failed to add local track ${idx}: ${e.message}`,
								);
								console.error("Local track error:", e);
							}
						}
					});

					if (tracksAdded === 0) {
						throw new Error(
							"No audio tracks available for recording",
						);
					}

					log(
						`Connected ${tracksAdded} audio tracks to recording stream`,
					);
					log(
						`Recording stream has ${recordingStream.getAudioTracks().length} tracks`,
					);

					// Check if MediaRecorder is available
					if (!window.MediaRecorder) {
						throw new Error("MediaRecorder not supported");
					}

					if (!MediaRecorder.isTypeSupported) {
						throw new Error(
							"MediaRecorder.isTypeSupported not available",
						);
					}

					// Find supported MIME type
					// Prefer M4A (MP4/AAC) on iOS; WebM on other platforms
					const isIOS =
						(window.Capacitor &&
							typeof window.Capacitor.getPlatform ===
								"function" &&
							window.Capacitor.getPlatform() === "ios") ||
						/\(iPad|iPhone|iPod\)/.test(navigator.userAgent);
					const options = isIOS
						? [
								"audio/mp4;codecs=mp4a.40.2", // M4A/AAC
								"audio/mp4",
								"audio/aac",
								"audio/webm;codecs=opus",
								"audio/webm",
								"audio/ogg;codecs=opus",
								"audio/wav",
							]
						: [
								"audio/webm;codecs=opus",
								"audio/webm",
								"audio/ogg;codecs=opus",
								"audio/mp4;codecs=mp4a.40.2",
								"audio/mp4",
								"audio/mpeg",
								"audio/wav",
							];

					log("Checking supported audio formats...");
					let mimeType = null;
					for (let option of options) {
						const supported = MediaRecorder.isTypeSupported(option);
						log(`  ${option}: ${supported ? "‚úì" : "‚úó"}`);
						if (supported && !mimeType) {
							mimeType = option;
						}
					}

					if (!mimeType) {
						// Fallback to platform-default
						mimeType = isIOS ? "audio/mp4" : "audio/webm";
						log(
							`No preferred format supported, using default: ${mimeType}`,
						);
					} else {
						log(`Selected MIME type: ${mimeType}`);
					}

					// Verify the stream has tracks before creating MediaRecorder
					if (recordingStream.getTracks().length === 0) {
						throw new Error("Recording stream has no tracks");
					}

					// Create MediaRecorder
					recordedChunks = [];
					log("Creating MediaRecorder...");
					mediaRecorder = new MediaRecorder(recordingStream, {
						mimeType: mimeType,
					});

					mediaRecorder.ondataavailable = (event) => {
						if (event.data && event.data.size > 0) {
							recordedChunks.push(event.data);
							log(
								`Recording data chunk: ${event.data.size} bytes (total chunks: ${recordedChunks.length})`,
							);
						}
					};

					mediaRecorder.onstop = async () => {
						log(
							`Recording stopped. Total chunks: ${recordedChunks.length}, total size: ${recordedChunks.reduce((sum, chunk) => sum + chunk.size, 0)} bytes`,
						);
						await saveRecording();
					};

					mediaRecorder.onerror = (event) => {
						log(
							`Recording error: ${event.error || "Unknown error"}`,
						);
						console.error("Recording error:", event);
						isRecording = false;
					};

					// Store call info for recording metadata
					recordingCallStartTime = callStartTime || Date.now();
					recordingCallerNumber =
						__callDirection === "outgoing"
							? __originalCallNumber || "Unknown"
							: __incomingRaw || __incomingDisplay || "Unknown";
					recordingCallDirection = __callDirection || "unknown";

					// Start recording
					log("Starting MediaRecorder...");
					mediaRecorder.start(1000); // Collect data every second
					isRecording = true;
					log("Recording started successfully");
				} catch (error) {
					log(`Failed to start recording: ${error.message}`);
					console.error("Recording start error:", error);
					isRecording = false;

					// Clean up on error
					if (recordingAudioContext) {
						try {
							recordingAudioContext.close();
						} catch (e) {}
						recordingAudioContext = null;
						recordingDestination = null;
						recordingStream = null;
					}
				}
			}

			async function stopRecording() {
				if (!isRecording || !mediaRecorder) {
					return null;
				}

				try {
					// Generate filename before stopping (so we can use it for history entry)
					const callerNumber = recordingCallerNumber || "Unknown";
					const filenameTimestamp = new Date()
						.toISOString()
						.replace(/[:.]/g, "-");
					const filename = `call-${callerNumber}-${filenameTimestamp}.${getFileExtension(mediaRecorder.mimeType)}`;
					currentRecordingFilename = filename;

					if (mediaRecorder.state === "recording") {
						mediaRecorder.stop();
					}

					isRecording = false;
					log("Recording stopped, saving file...");

					// Clean up audio context
					if (recordingAudioContext) {
						recordingAudioContext.close();
						recordingAudioContext = null;
						recordingDestination = null;
						recordingStream = null;
					}

					// Wait a bit for saveRecording to complete (it's called from MediaRecorder's onstop event)
					// Then clear metadata and return filename
					await new Promise((resolve) => setTimeout(resolve, 500));

					const savedFilename = currentRecordingFilename;

					// Clear recording metadata
					recordingCallStartTime = null;
					recordingCallerNumber = null;
					recordingCallDirection = null;
					currentRecordingFilename = null;

					return savedFilename;
				} catch (error) {
					log(`Failed to stop recording: ${error.message}`);
					console.error("Recording stop error:", error);
					isRecording = false;
					currentRecordingFilename = null;
					return null;
				}
			}

			async function saveRecording() {
				if (recordedChunks.length === 0) {
					log("No recording data to save");
					return;
				}

				try {
					const blob = new Blob(recordedChunks, {
						type: mediaRecorder.mimeType,
					});

					// Convert blob to base64 (handle large files properly)
					const base64 = await new Promise((resolve, reject) => {
						const reader = new FileReader();
						reader.onloadend = () => {
							const base64String = reader.result.split(",")[1]; // Remove data:audio/webm;base64, prefix
							resolve(base64String);
						};
						reader.onerror = reject;
						reader.readAsDataURL(blob);
					});

					// Use filename generated in stopRecording() or generate new one
					const callerNumber = recordingCallerNumber || "Unknown";
					const callTimestamp = recordingCallStartTime
						? new Date(recordingCallStartTime).toISOString()
						: new Date().toISOString();
					const filename =
						currentRecordingFilename ||
						(() => {
							const filenameTimestamp = new Date()
								.toISOString()
								.replace(/[:.]/g, "-");
							return `call-${callerNumber}-${filenameTimestamp}.${getFileExtension(mediaRecorder.mimeType)}`;
						})();

					// Save to native platform
					const isNative =
						window.Capacitor &&
						((window.Capacitor.isNativePlatform &&
							window.Capacitor.isNativePlatform()) ||
							(window.Capacitor.getPlatform &&
								window.Capacitor.getPlatform() !== "web"));

					if (isNative) {
						const CallService =
							window.Capacitor.Plugins?.CallService;
						const Filesystem = window.Capacitor.Plugins?.Filesystem;

						// Try native plugin first (saves to Application Support on iOS)
						if (CallService?.saveRecording) {
							try {
								await CallService.saveRecording({
									filename: filename,
									data: base64,
									mimeType: mediaRecorder.mimeType,
								});
								log(`Recording saved: ${filename}`);

								await Storage.updateCallHistoryWithRecording(
									filename,
								);
								await Storage.addRecordingToHistory({
									filename: filename,
									callerNumber: callerNumber,
									direction:
										recordingCallDirection || "unknown",
									timestamp: callTimestamp,
									duration: getCallDuration(),
								});
								return;
							} catch (error) {
								console.error(
									"Native plugin save failed:",
									error,
								);
							}
						}

						// Fallback to Filesystem plugin (saves to Documents on iOS)
						if (Filesystem?.writeFile) {
							try {
								await Filesystem.mkdir({
									path: "CallRecordings",
									directory: "DATA",
									recursive: true,
								}).catch(() => {});

								// Write base64 data (Capacitor auto-decodes to binary)
								await Filesystem.writeFile({
									path: `CallRecordings/${filename}`,
									data: base64,
									directory: "DATA",
								});

								log(`Recording saved: ${filename}`);
								await Storage.updateCallHistoryWithRecording(
									filename,
								);
								await Storage.addRecordingToHistory({
									filename: filename,
									callerNumber: callerNumber,
									direction:
										recordingCallDirection || "unknown",
									timestamp: callTimestamp,
									duration: getCallDuration(),
								});
								return;
							} catch (error) {
								console.error("Filesystem save failed:", error);
							}
						}
					}

					// Web fallback: download file
					downloadRecording(blob, filename);
				} catch (error) {
					log(`Failed to save recording: ${error.message}`);
					console.error("Recording stop error:", error);
					isRecording = false;
					currentRecordingFilename = null;
				}
			}

			function downloadRecording(blob, filename) {
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
				log(`Recording downloaded: ${filename}`);
			}

			function getFileExtension(mimeType) {
				if (mimeType.includes("webm")) return "webm";
				if (mimeType.includes("ogg")) return "ogg";
				if (mimeType.includes("mp4")) return "m4a"; // MP4 audio is typically M4A
				if (mimeType.includes("aac")) return "m4a"; // Prefer .m4a container naming for AAC
				if (mimeType.includes("mpeg") || mimeType.includes("mp3"))
					return "mp3";
				if (mimeType.includes("wav")) return "wav";
				return "webm";
			}

			function getCallDuration() {
				if (!callStartTime) return "00:00";
				const duration = Math.floor(
					(Date.now() - callStartTime) / 1000,
				);
				const minutes = Math.floor(duration / 60);
				const seconds = duration % 60;
				return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
			}

			function showCallControls() {
				document.getElementById("callControls").classList.add("active");
				document.getElementById("callBtn").disabled = true;
				hideDialpad();

				// Request wake lock to prevent screen sleep during calls
				requestWakeLock();

				// Start Android foreground service to keep call alive in background
				const callNumber =
					__originalCallNumber ||
					__incomingRaw ||
					document.getElementById("callNumber").value ||
					"";
				startCallService(callNumber);
			}

			function hideCallControls() {
				document
					.getElementById("callControls")
					.classList.remove("active");
				document.getElementById("callBtn").disabled = false;
				showDialpad();

				// Release wake lock when call ends
				releaseWakeLock();
				stopCallTimer();

				// Stop Android foreground service
				stopCallService();
			}

			async function endCall() {
				// Clean up WebSocket event listeners
				if (
					userAgent &&
					userAgent.transport &&
					userAgent.transport.ws &&
					webSocketMessageHandler
				) {
					userAgent.transport.ws.removeEventListener(
						"message",
						webSocketMessageHandler,
					);
					webSocketMessageHandler = null;
				}

				// Release wake lock when call ends
				releaseWakeLock();
				// Stop call timer
				stopCallTimer();

				// Stop Android foreground service
				stopCallService();

				// Stop recording if active and get filename (must be done before saving history)
				let recordingFilename = null;
				if (isRecording) {
					recordingFilename = await stopRecording();
				}

				// Save call to history (with recording filename if available)
				try {
					if (__callDirection === "outgoing") {
						const num = __originalCallNumber || "Unknown";
						Storage.addCallToHistory(
							"outgoing",
							num,
							"Connected",
							recordingFilename,
						);
					} else if (__callDirection === "incoming") {
						const num =
							__incomingRaw && __incomingRaw !== "Unknown"
								? __incomingRaw
								: __incomingDisplay || "Unknown";
						Storage.addCallToHistory(
							"incoming",
							num,
							"Connected",
							recordingFilename,
						);
					}
				} catch (e) {
					console.error("Failed to save call history:", e);
				}

				currentSession = null;
				__callDirection = null;
				__answeredIncoming = false;
				activeCall = false;
				hideCallControls();
				isMuted = false;
				document.getElementById("muteBtn").textContent = "Mute";
				document.getElementById("callStatus").textContent =
					"Call in progress";
				document.getElementById("callNumber").placeholder =
					"Enter number to dial / DTMF during call";

				// Hide the "Show Dialpad" button when call ends
				const showDialpadBtn =
					document.getElementById("showDialpadBtn");
				if (showDialpadBtn) {
					showDialpadBtn.style.display = "none";
				}

				// Handle Bluetooth audio disconnect
				handleBluetoothDisconnect();
			}

			function startCallTimer() {
				callStartTime = Date.now();
				callTimer = setInterval(updateCallDuration, 1000);
			}

			function stopCallTimer() {
				if (callTimer) {
					clearInterval(callTimer);
					callTimer = null;
				}
				document.getElementById("callDuration").textContent = "00:00";
			}

			function updateCallDuration() {
				if (!callStartTime) return;
				const duration = Math.floor(
					(Date.now() - callStartTime) / 1000,
				);
				const minutes = Math.floor(duration / 60);
				const seconds = duration % 60;
				document.getElementById("callDuration").textContent =
					`${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
			}

			function appendNumber(num) {
				const input = document.getElementById("callNumber");

				if (currentSession) {
					const isEstablished =
						currentSession.dialog ||
						(currentSession.sessionDescriptionHandler &&
							currentSession.sessionDescriptionHandler
								.peerConnection);

					if (isEstablished) {
						if (sendDTMF(num)) {
							input.value = input.value + num;
						}
						return;
					}
				}

				input.value = input.value + num;
			}

			function clearNumber() {
				document.getElementById("callNumber").value = "";
			}

			function sendDTMF(digit) {
				if (!currentSession && !__answeredIncoming) {
					log("No active session for DTMF");
					return false;
				}

				const isEstablished =
					currentSession.dialog ||
					(currentSession.sessionDescriptionHandler &&
						currentSession.sessionDescriptionHandler
							.peerConnection);

				if (!isEstablished) {
					log("Call not fully established for DTMF");
					return false;
				}

				try {
					const options = {
						duration: DTMF_DURATION_MS,
						interToneGap: DTMF_INTERTONE_GAP_MS,
					};

					currentSession.dtmf(digit, options);
					log(`DTMF sent: ${digit} (${DTMF_DURATION_MS}ms duration)`);

					return true;
				} catch (error) {
					log(`DTMF failed: ${error.message}`);
					console.error("DTMF error:", error);
					return false;
				}
			}

			// Dialpad layer management
			function showDialpad() {
				const dialpadLayer = document.getElementById("dialpadLayer");
				const showDialpadBtn =
					document.getElementById("showDialpadBtn");
				if (dialpadLayer) {
					dialpadLayer.style.display = "block";
				}
				if (showDialpadBtn) {
					showDialpadBtn.style.display = "none";
				}
			}

			function hideDialpad() {
				const dialpadLayer = document.getElementById("dialpadLayer");
				const showDialpadBtn =
					document.getElementById("showDialpadBtn");
				if (dialpadLayer) {
					dialpadLayer.style.display = "none";
				}
				// Show the "Show Dialpad" button only if there's an active call
				if (showDialpadBtn && currentSession) {
					showDialpadBtn.style.display = "block";
				}
			}

			// Function to update event log visibility based on setting
			function updateEventLogVisibility() {
				const hideEventLogElement =
					document.getElementById("hideEventLog");
				if (!hideEventLogElement) {
					console.log(
						"hideEventLog element not found, skipping visibility update",
					);
					return;
				}

				const hideEventLog = hideEventLogElement.checked;
				const logButton = document.querySelector(
					'.header-toggle[title="Event Log"]',
				);
				const logSection = document.getElementById("logSection");

				console.log(
					"updateEventLogVisibility called, hideEventLog:",
					hideEventLog,
				);
				console.log("logButton found:", !!logButton);
				console.log("logSection found:", !!logSection);

				if (hideEventLog) {
					// Hide the event log button and section
					if (logButton) {
						logButton.style.display = "none";
						console.log("Event log button hidden");
					}
					if (logSection) {
						logSection.style.display = "none";
						console.log("Event log section hidden");
					}
				} else {
					// Show the event log button and section by removing the style (restores original CSS)
					if (logButton) {
						logButton.style.display = "";
						console.log(
							"Event log button shown (restored original styling)",
						);
					}
					if (logSection) {
						logSection.style.display = "";
						console.log(
							"Event log section shown (restored original styling)",
						);
					}
				}
			}

			// View management
			function setView(view) {
				const sections = {
					call: document.getElementById("callSection"),
					config: document.getElementById("configSection"),
					log: document.getElementById("logSection"),
					contacts: document.getElementById("contactsSection"),
					history: document.getElementById("historySection"),
				};

				// Hide all sections
				Object.values(sections).forEach((section) => {
					if (section) {
						section.classList.remove("visible");
						section.classList.add("hidden");
					}
				});

				// Show requested view
				if (view === "phone") {
					sections.call.classList.remove("hidden");
					showDialpad();
				} else if (view === "settings") {
					sections.config.classList.add("visible");
					sections.config.classList.remove("hidden");
				} else if (view === "log") {
					sections.log.classList.add("visible");
					sections.log.classList.remove("hidden");
				} else if (view === "contacts") {
					sections.contacts.classList.add("visible");
					sections.contacts.classList.remove("hidden");
				} else if (view === "history") {
					sections.history.classList.add("visible");
					sections.history.classList.remove("hidden");
					renderCallHistory();
				}

				// Update header buttons
				document
					.querySelectorAll(".header-toggle")
					.forEach((btn) => btn.classList.remove("active"));
				const titleMap = {
					phone: "Phone",
					contacts: "Contacts",
					settings: "Settings",
					log: "Event Log",
					history: "Call History",
				};
				const activeBtn = document.querySelector(
					`.header-toggle[title="${titleMap[view] || "Phone"}"]`,
				);
				if (activeBtn) activeBtn.classList.add("active");
			}

			window.showPhone = () => setView("phone");
			window.showContacts = () => setView("contacts");
			window.showSettings = () => setView("settings");
			window.showLog = () => setView("log");
			window.showHistory = () => setView("history");

			// Call history functions
			async function renderCallHistory() {
				const el = document.getElementById("callHistory");
				if (!el) return;

				const history = await Storage.getHistory();

				if (history.length === 0) {
					el.innerHTML = `
						<div class="contact-item" style="text-align: center; padding: 20px; color: #666;">
							<p style="font-size: 14px;">No call history yet</p>
						</div>
					`;
					return;
				}

				el.innerHTML = "";
				history.forEach((item, index) => {
					let icon = "‚ùì"; // Default for unknown
					let callType = "Unknown";

					if (item.type === "incoming") {
						icon = "‚¨áÔ∏è"; // Incoming answered call
						callType = "Incoming";
					} else if (item.type === "outgoing") {
						icon = "‚¨ÜÔ∏è"; // Outgoing call
						callType = "Outgoing";
					} else if (item.type === "missed") {
						icon = "üî¥"; // Missed call (rang but not answered)
						callType = "Missed";
					} else if (item.type === "declined") {
						icon = "‚õî"; // Declined call (explicitly rejected)
						callType = "Declined";
					}

					// Format phone number consistently
					let displayNumber = item.number;
					const cleanNumber = item.number.replace(/\D/g, "");

					if (cleanNumber.length === 10) {
						// US format: (555) 123-4567
						displayNumber = `(${cleanNumber.slice(0, 3)}) ${cleanNumber.slice(3, 6)}-${cleanNumber.slice(6)}`;
					} else if (
						cleanNumber.length === 11 &&
						cleanNumber.startsWith("1")
					) {
						// 11 digits starting with 1: show as 10-digit format (555) 123-4567
						displayNumber = `(${cleanNumber.slice(1, 4)}) ${cleanNumber.slice(4, 7)}-${cleanNumber.slice(7)}`;
					} else if (cleanNumber.length === 7) {
						// Local format: 123-4567
						displayNumber = `${cleanNumber.slice(0, 3)}-${cleanNumber.slice(3)}`;
					} else if (cleanNumber.length > 11) {
						// International format: +XX XXX XXX XXXX
						const countryCode = cleanNumber.slice(
							0,
							cleanNumber.length - 10,
						);
						const areaCode = cleanNumber.slice(
							cleanNumber.length - 10,
							cleanNumber.length - 7,
						);
						const firstPart = cleanNumber.slice(
							cleanNumber.length - 7,
							cleanNumber.length - 4,
						);
						const lastPart = cleanNumber.slice(
							cleanNumber.length - 4,
						);
						displayNumber = `+${countryCode} ${areaCode} ${firstPart} ${lastPart}`;
					}

					const timestamp = new Date(item.timestamp).toLocaleString();
					const safeNumber = cleanNumber
						.replace(/'/g, "\\'")
						.replace(/"/g, '\\"');

					// Check if this call has a recording (stored directly in history entry)
					const recordingFilename = item.recording || null;

					const historyDiv = document.createElement("div");
					historyDiv.className = "contact-item";
					historyDiv.style.cssText = `
						padding: 16px 20px;
						border-bottom: 1px solid #f0f0f0;
						cursor: pointer;
						transition: all 0.2s ease;
						background: white;
					`;

					// Create the history display HTML
					let recordingHTML = "";
					if (recordingFilename) {
						recordingHTML = `
							<div style="margin-top: 8px; margin-left: 30px;">
								<audio
									id="history-recording-${index}"
									controls
									playsinline
									style="width: 100%; max-width: 350px; height: 32px;"
									preload="metadata"
								>
									Your browser does not support the audio element.
								</audio>
							</div>
						`;
					}

					const historyHTML = `
						<div style="padding: 6px 0;">
							<div style="display: flex; align-items: center; gap: 12px; margin-bottom: 4px;">
								<span style="font-size: 18px;">${icon}</span>
								<div style="flex: 1;">
									<button onclick="redial('${safeNumber}')"
										style="background: none; border: none; color: #007bff; text-decoration: underline; cursor: pointer; font-family: monospace; font-size: 12px; padding: 0; text-align: left; font-weight: 600;">
										${displayNumber}
									</button>
									<div style="font-size: 10px; color: #888; text-transform: capitalize; margin-top: 2px;">
										${callType.toLowerCase()}
									</div>
								</div>
							</div>
							<div style="font-size: 10px; color: #666; margin-left: 30px;">
								${timestamp}
							</div>
							${recordingHTML}
						</div>
					`;

					historyDiv.innerHTML = historyHTML;

					historyDiv.addEventListener("mouseenter", () => {
						historyDiv.style.backgroundColor = "#f5f5f5";
					});
					historyDiv.addEventListener("mouseleave", () => {
						historyDiv.style.backgroundColor = "transparent";
					});

					el.appendChild(historyDiv);

					// Load recording audio source if available
					if (recordingFilename) {
						setTimeout(async () => {
							const audioEl = document.getElementById(
								`history-recording-${index}`,
							);
							if (!audioEl) return;

							try {
								if (
									window.Capacitor &&
									window.Capacitor.isNativePlatform()
								) {
									const platform = window.Capacitor
										.getPlatform
										? window.Capacitor.getPlatform()
										: "unknown";

									// Single path: VTCallService on all platforms
									const { VTCallService } =
										window.Capacitor.Plugins;
									if (!VTCallService)
										throw new Error(
											"VTCallService not available",
										);

									const result =
										await VTCallService.getRecordingFileUrl(
											{ filename: recordingFilename },
										);

									if (result && result.url) {
										// Convert data URL to blob URL for both platforms to avoid size limits
										// This is more memory efficient and works better for long recordings
										const match = result.url.match(
											/^data:([^;]+);base64,(.+)$/,
										);
										if (match) {
											const mimeType = match[1];
											const base64Data = match[2];

											// Decode base64 to binary
											const bytes = atob(base64Data);
											const arr = new Uint8Array(
												bytes.length,
											);
											for (
												let i = 0;
												i < bytes.length;
												i++
											) {
												arr[i] = bytes.charCodeAt(i);
											}

											// Create blob URL (more efficient than data URLs for large files)
											const blob = new Blob([arr], {
												type: mimeType,
											});
											const blobUrl =
												URL.createObjectURL(blob);

											// Clean up old blob URL if exists
											if (audioEl._oldBlobUrl) {
												URL.revokeObjectURL(
													audioEl._oldBlobUrl,
												);
											}
											audioEl._oldBlobUrl = blobUrl;
											audioEl.src = blobUrl;
										} else {
											// Fallback: use URL directly if not a data URL
											audioEl.src = result.url;
										}
									}

									audioEl.addEventListener(
										"error",
										(e) => {
											console.error(
												"Recording playback error:",
												audioEl.error,
											);
										},
										{ once: true },
									);
								}
							} catch (error) {
								console.error(
									"Error loading recording:",
									error,
								);
							}
						}, 100);
					}
				});
			}

			async function clearHistory() {
				await Storage.clearHistory();
				renderCallHistory();
			}

			async function clearRecordings() {
				try {
					// Get all recordings from metadata storage
					const recordings = await Storage.getRecordings();

					// Get all history entries to find recording filenames
					const history = await Storage.getHistory();
					const historyRecordings = history
						.filter((item) => item.recording)
						.map((item) => item.recording);

					// Combine all recording filenames (remove duplicates)
					const allRecordings = [
						...new Set([
							...recordings.map((r) => r.filename),
							...historyRecordings,
						]),
					];

					log(`Deleting ${allRecordings.length} recording files...`);

					// Delete all recording files via native plugin
					let deletedCount = 0;
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins &&
						window.Capacitor.Plugins.CallService
					) {
						const CallService =
							window.Capacitor.Plugins.CallService;
						for (const filename of allRecordings) {
							try {
								const result =
									await CallService.deleteRecordingFile({
										filename,
									});
								if (result && result.success) {
									deletedCount++;
								}
							} catch (error) {
								console.error(
									`Failed to delete ${filename}:`,
									error,
								);
							}
						}
					}

					// Clear recordings metadata storage
					await Storage.clearRecordings();

					// Remove recording field from all history entries
					for (const item of history) {
						if (item.recording) {
							delete item.recording;
						}
					}
					await localforage.setItem(Storage.HISTORY_KEY, history);

					log(`Deleted ${deletedCount} recording files.`);

					// Refresh call history display
					renderCallHistory();
				} catch (error) {
					log(`Failed to clear recordings: ${error.message}`);
					console.error("Clear recordings error:", error);
				}
			}

			// Contact management functions
			let contactsList = [];

			async function loadContacts() {
				try {
					// Check if Capacitor and Contacts plugin are available
					if (
						!window.Capacitor ||
						!window.Capacitor.Plugins ||
						!window.Capacitor.Plugins.Contacts
					) {
						log(
							"Contacts plugin not available - make sure you're running on a device",
						);
						alert(
							"Contacts plugin is not available. Please make sure you're running the app on a mobile device.",
						);
						return;
					}

					const Contacts = window.Capacitor.Plugins.Contacts;
					log("Requesting contacts permission...");
					const permission = await Contacts.requestPermissions();

					if (permission.contacts === "granted") {
						log("Loading contacts...");
						const result = await Contacts.getContacts({
							projection: {
								name: true,
								phones: true,
								emails: true,
								image: true,
							},
						});

						contactsList = result.contacts || [];
						log(`Loaded ${contactsList.length} contacts`);

						// Debug: Log the first contact to see the structure
						if (contactsList.length > 0) {
							console.log(
								"First contact structure:",
								contactsList[0],
							);
							log(
								"First contact: " +
									JSON.stringify(contactsList[0]),
							);
						}

						renderContacts();
					} else {
						log("Contacts permission denied");
						alert(
							"Contacts permission is required to load your contacts.",
						);
					}
				} catch (error) {
					log(`Error loading contacts: ${error.message}`);
					console.error("Contacts error:", error);
				}
			}

			function renderContacts() {
				const el = document.getElementById("contactsList");
				if (!el) return;

				if (contactsList.length === 0) {
					el.innerHTML = `
						<div class="contact-item" style="text-align: center; padding: 20px; color: #666;">
							<button class="btn-primary" onclick="loadContacts()">
								üì± Load Contacts
							</button>
							<p style="margin-top: 10px; font-size: 14px;">
								Tap to load your device contacts
							</p>
						</div>
					`;
					return;
				}

				// Filter contacts that have phone numbers and clean/unique them
				const contactsWithPhones = contactsList.filter((contact) => {
					const phones = contact.phones || [];
					return (
						phones.length > 0 &&
						phones.some((phone) => {
							const phoneNumber =
								typeof phone === "string"
									? phone
									: phone.number;
							return phoneNumber && phoneNumber.trim().length > 0;
						})
					);
				});

				// Sort contacts alphabetically by name
				contactsWithPhones.sort((a, b) => {
					// Extract names for comparison
					let nameA = "Unknown";
					let nameB = "Unknown";

					if (a.name) {
						if (typeof a.name === "string") {
							nameA = a.name;
						} else if (a.name.display) {
							nameA = a.name.display;
						} else if (a.name.given || a.name.family) {
							nameA =
								`${a.name.given || ""} ${a.name.family || ""}`.trim();
						} else if (a.name.givenName || a.name.familyName) {
							nameA =
								`${a.name.givenName || ""} ${a.name.familyName || ""}`.trim();
						} else if (a.name.displayName) {
							nameA = a.name.displayName;
						}
					} else if (a.displayName) {
						nameA = a.displayName;
					}

					if (b.name) {
						if (typeof b.name === "string") {
							nameB = b.name;
						} else if (b.name.display) {
							nameB = b.name.display;
						} else if (b.name.given || b.name.family) {
							nameB =
								`${b.name.given || ""} ${b.name.family || ""}`.trim();
						} else if (b.name.givenName || b.name.familyName) {
							nameB =
								`${b.name.givenName || ""} ${b.name.familyName || ""}`.trim();
						} else if (b.name.displayName) {
							nameB = b.name.displayName;
						}
					} else if (b.displayName) {
						nameB = b.displayName;
					}

					// Compare names alphabetically (case-insensitive)
					return nameA
						.toLowerCase()
						.localeCompare(nameB.toLowerCase());
				});

				if (contactsWithPhones.length === 0) {
					el.innerHTML = `
						<div class="contact-item" style="text-align: center; padding: 20px; color: #666;">
							<p>No contacts with phone numbers found</p>
						</div>
					`;
					return;
				}

				el.innerHTML = "";
				contactsWithPhones.forEach((contact, index) => {
					// Extract contact information properly - handle different data structures
					let name = "Unknown";
					if (contact.name) {
						if (typeof contact.name === "string") {
							name = contact.name;
						} else if (contact.name.display) {
							name = contact.name.display;
						} else if (contact.name.given || contact.name.family) {
							name =
								`${contact.name.given || ""} ${contact.name.family || ""}`.trim();
						} else if (
							contact.name.givenName ||
							contact.name.familyName
						) {
							name =
								`${contact.name.givenName || ""} ${contact.name.familyName || ""}`.trim();
						} else if (contact.name.displayName) {
							name = contact.name.displayName;
						}
					} else if (contact.displayName) {
						name = contact.displayName;
					}

					// Create a safe display name (escape quotes) - only if name is a string
					const safeName =
						typeof name === "string"
							? name.replace(/'/g, "\\'").replace(/"/g, '\\"')
							: "Unknown";

					const phones = contact.phones || [];
					let phoneLines = "";
					const uniquePhones = new Set(); // Track unique phone numbers

					phones.forEach((phone, index) => {
						let phoneNumber = "";
						let phoneType = "Phone";

						if (typeof phone === "string") {
							phoneNumber = phone;
							phoneType = "Phone";
						} else if (phone.number) {
							phoneNumber = phone.number;
							phoneType = phone.type || "Phone";
						}

						if (phoneNumber) {
							// Clean the phone number (remove all non-digits)
							const cleanNumber = phoneNumber.replace(/\D/g, "");

							// Only add if we haven't seen this number before and it's not empty
							if (
								cleanNumber.length > 0 &&
								!uniquePhones.has(cleanNumber)
							) {
								uniquePhones.add(cleanNumber);

								// Format the display number based on length
								let displayNumber = cleanNumber;
								if (cleanNumber.length === 10) {
									// US format: (555) 123-4567
									displayNumber = `(${cleanNumber.slice(0, 3)}) ${cleanNumber.slice(3, 6)}-${cleanNumber.slice(6)}`;
								} else if (
									cleanNumber.length === 11 &&
									cleanNumber.startsWith("1")
								) {
									// 11 digits starting with 1: show as 10-digit format (555) 123-4567
									displayNumber = `(${cleanNumber.slice(1, 4)}) ${cleanNumber.slice(4, 7)}-${cleanNumber.slice(7)}`;
								} else if (cleanNumber.length === 7) {
									// Local format: 123-4567
									displayNumber = `${cleanNumber.slice(0, 3)}-${cleanNumber.slice(3)}`;
								} else if (cleanNumber.length > 11) {
									// International format: +XX XXX XXX XXXX
									const countryCode = cleanNumber.slice(
										0,
										cleanNumber.length - 10,
									);
									const areaCode = cleanNumber.slice(
										cleanNumber.length - 10,
										cleanNumber.length - 7,
									);
									const firstPart = cleanNumber.slice(
										cleanNumber.length - 7,
										cleanNumber.length - 4,
									);
									const lastPart = cleanNumber.slice(
										cleanNumber.length - 4,
									);
									displayNumber = `+${countryCode} ${areaCode} ${firstPart} ${lastPart}`;
								}

								const safePhone = cleanNumber
									.replace(/'/g, "\\'")
									.replace(/"/g, '\\"');
								phoneLines += `
									<div style="display: flex; align-items: center; justify-content: flex-start; gap: 8px; margin: 2px 0; padding: 3px 0;">
										<button onclick="callContact('${safePhone}', '${safeName}')"
											style="background: none; border: none; color: #007bff; text-decoration: underline; cursor: pointer; font-family: monospace; font-size: 12px; padding: 0; text-align: left;">
											${displayNumber}
										</button>
										<span style="font-size: 10px; color: #888; text-transform: capitalize; min-width: 50px; text-align: left;">
											${phoneType.toLowerCase()}
										</span>
									</div>
								`;
							}
						}
					});

					const contactDiv = document.createElement("div");
					contactDiv.className = "contact-item";
					contactDiv.style.cssText = `
						padding: 16px 20px;
						border-bottom: 1px solid #f0f0f0;
						cursor: pointer;
						transition: all 0.2s ease;
						background: white;
					`;

					// Create the contact display HTML with multiple phone numbers
					const contactHTML = `
						<div style="padding: 6px 0;">
							<div style="font-weight: 600; font-size: 14px; color: #333; margin-bottom: 6px;">
								${safeName}
							</div>
							${phoneLines}
						</div>
					`;

					contactDiv.innerHTML = contactHTML;

					contactDiv.addEventListener("mouseenter", () => {
						contactDiv.style.backgroundColor = "#f5f5f5";
					});
					contactDiv.addEventListener("mouseleave", () => {
						contactDiv.style.backgroundColor = "transparent";
					});

					el.appendChild(contactDiv);
				});
			}

			function callContact(phoneNumber, contactName) {
				// Clean the phone number
				const cleanNumber = phoneNumber.replace(/\D/g, "");
				document.getElementById("callNumber").value = cleanNumber;
				__originalCallNumber = cleanNumber; // Store original number for call history
				setView("phone");

				if (isRegistered) {
					makeCall();
				} else {
					log("Please register first before making calls");
				}
			}

			function clearContacts() {
				contactsList = [];
				renderContacts();
				log("Contacts cleared");
			}

			// Contact search functionality
			function setupContactSearch() {
				const searchInput = document.getElementById("contactSearch");
				if (searchInput) {
					searchInput.addEventListener("input", (e) => {
						const query = e.target.value.toLowerCase();
						if (query === "") {
							renderContacts();
							return;
						}

						const filteredContacts = contactsList.filter(
							(contact) => {
								// Extract contact name properly - same logic as renderContacts
								let name = "Unknown";
								if (contact.name) {
									if (typeof contact.name === "string") {
										name = contact.name;
									} else if (contact.name.display) {
										name = contact.name.display;
									} else if (
										contact.name.given ||
										contact.name.family
									) {
										name =
											`${contact.name.given || ""} ${contact.name.family || ""}`.trim();
									} else if (
										contact.name.givenName ||
										contact.name.familyName
									) {
										name =
											`${contact.name.givenName || ""} ${contact.name.familyName || ""}`.trim();
									} else if (contact.name.displayName) {
										name = contact.name.displayName;
									}
								} else if (contact.displayName) {
									name = contact.displayName;
								}

								const nameMatch = name
									.toLowerCase()
									.includes(query);
								const phones = contact.phones || [];
								const phoneMatch = phones.some((phone) => {
									const phoneNumber =
										typeof phone === "string"
											? phone
											: phone.number;
									return (
										phoneNumber &&
										phoneNumber
											.toLowerCase()
											.includes(query)
									);
								});
								return nameMatch || phoneMatch;
							},
						);

						// Temporarily replace contactsList for rendering
						const originalContacts = contactsList;
						contactsList = filteredContacts;
						renderContacts();
						contactsList = originalContacts;
					});
				}
			}

			function redial(num) {
				try {
					document.getElementById("callNumber").value = (
						num || ""
					).replace(/[^0-9+]/g, "");
					setView("phone");
					if (isRegistered) {
						makeCall();
					}
				} catch (e) {
					console.error("Redial failed:", e);
				}
				return false;
			}

			// Clear all data
			async function clearAllData() {
				// Clear form fields
				[
					"username",
					"password",
					"displayName",
					"callerID",
					"callNumber",
				].forEach((id) => {
					const el = document.getElementById(id);
					if (el) el.value = "";
				});

				// Clear checkboxes
				[
					"saveCredentials",
					"hideCallerID",
					"registerOnStartup",
					"hideEventLog",
				].forEach((id) => {
					const el = document.getElementById(id);
					if (el) el.checked = false;
				});

				// Clear storage
				await Storage.clearAll();

				// Refresh call history display
				await renderCallHistory();
			}

			// App state management for re-registration
			function setupAppStateListeners() {
				log("Setting up app state listeners...");

				// Always set up visibility change listener as primary method
				document.addEventListener(
					"visibilitychange",
					async function () {
						log(
							"Visibility change detected - document.hidden: " +
								document.hidden,
						);
						if (!document.hidden) {
							log(
								"App brought to foreground (visibility) - WebSocket may have been killed, checking if re-registration needed...",
							);
							await reRegister(); // AWAIT the async function to ensure service check completes
						} else {
							log(
								"App moved to background (visibility) - WebSocket will likely be killed",
							);
						}
					},
				);

				log("Visibility change listener added");

				// Try to set up Capacitor listeners if available (only once)
				setTimeout(() => {
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform()
					) {
						log(
							"Capacitor detected - setting up native app state listeners",
						);

						// Try to access Capacitor App API
						if (
							window.Capacitor.Plugins &&
							window.Capacitor.Plugins.App
						) {
							const App = window.Capacitor.Plugins.App;

							// Listen for app state changes (only one listener)
							App.addListener(
								"appStateChange",
								async ({ isActive }) => {
									if (isActive) {
										log(
											"App brought to foreground (Capacitor) - checking registration",
										);
										await reRegister(); // AWAIT the async function to ensure service check completes
									} else {
										log(
											"App moved to background (Capacitor)",
										);
									}
								},
							);

							log("Capacitor app state listeners configured");
						} else {
							log("Capacitor App plugin not available");
						}
					} else {
						log(
							"Not running on native platform - using visibility API only",
						);
					}
				}, 2000);
			}

			// Re-registration function with debouncing
			async function reRegister() {
				log("=== RE-REGISTER FUNCTION CALLED ===");
				// If there is a pending incoming session, never re-register
				if (incomingSession) {
					log("RE-REGISTER: Incoming session pending - skipping");
					return;
				}

				// CRITICAL: Do not re-register if there's an active call!
				// First check: If we just returned from notification tap, skip re-registration
				// This flag is set by MainActivity.onNewIntent() when notification is tapped
				// The notification is only shown during active calls, so skip re-registration
				if (window.__skipReRegisterForNotification === true) {
					log(
						"RE-REGISTER: Returning from notification tap (active call) - IMMEDIATELY skipping re-registration",
					);
					return;
				}

				// Second check: If CallForegroundService is running, there's definitely an active call
				// This is the most reliable check - service only runs during calls
				// MUST check this BEFORE setting timeout - this blocks until we know
				if (
					window.Capacitor &&
					window.Capacitor.isNativePlatform() &&
					window.Capacitor.Plugins &&
					window.Capacitor.Plugins.CallService
				) {
					log(
						"RE-REGISTER: Checking if CallForegroundService is running...",
					);
					try {
						const CallService =
							window.Capacitor.Plugins.CallService;
						const result = await CallService.isServiceRunning();
						log(
							"RE-REGISTER: Service check result: " +
								JSON.stringify(result),
						);
						if (result && result.isRunning === true) {
							log(
								"RE-REGISTER: CallForegroundService is running (active call) - IMMEDIATELY skipping re-registration",
							);
							// Clear any pending timeout
							if (reRegisterTimeout) {
								clearTimeout(reRegisterTimeout);
								reRegisterTimeout = null;
							}
							return;
						} else {
							log(
								"RE-REGISTER: CallForegroundService is NOT running (isRunning=" +
									(result ? result.isRunning : "null") +
									") - will proceed with re-registration check",
							);
						}
					} catch (err) {
						log(
							"RE-REGISTER: Failed to check service status: " +
								(err.message || err) +
								" - will proceed with other checks",
						);
						console.error("Service check error:", err);
					}
				} else {
					log(
						"RE-REGISTER: CallService plugin not available - skipping service check",
					);
				}

				// Second check: currentSession - if it exists, it means there's either:
				// 1. An active call (has dialog or peer connection)
				// 2. A call in progress (INVITE sent but not yet answered)
				// In both cases, we must NOT re-register as it would terminate the call
				if (currentSession) {
					// Check if session has a request (INVITE sent/received) or is established (has dialog/peerConnection)
					const hasRequest =
						currentSession.request !== null &&
						currentSession.request !== undefined;
					const hasDialog =
						currentSession.dialog !== null &&
						currentSession.dialog !== undefined;
					const hasPeerConnection =
						currentSession.sessionDescriptionHandler &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== null &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== undefined;
					// Session is active if it has a request (call in progress) OR is established (has dialog/connection)
					const isActive =
						hasRequest || hasDialog || hasPeerConnection;

					if (isActive) {
						log(
							"RE-REGISTER: Active call detected (currentSession exists with request/dialog/connection) - IMMEDIATELY skipping re-registration to avoid terminating call",
						);
						return;
					} else {
						// Session exists but appears inactive - this is a stale reference, clear it
						log(
							"RE-REGISTER: Found stale currentSession reference (no request/dialog/connection) - clearing and will proceed with re-registration",
						);
						currentSession = null;
					}
				}

				// Third check: If we just returned from notification tap during a call,
				// give JavaScript state a moment to restore before checking again
				// This is a safety net in case currentSession check above didn't catch it

				log(
					"App brought to foreground - WebSocket may have been killed, checking if re-registration needed...",
				);

				// Clear any existing timeout
				if (reRegisterTimeout) {
					clearTimeout(reRegisterTimeout);
					log("Cleared previous re-registration timeout");
				}

				// Debounce re-registration - only execute after 500ms of no new calls
				reRegisterTimeout = setTimeout(async () => {
					// Check notification flag again in debounce (might be set during delay)
					if (window.__skipReRegisterForNotification === true) {
						log(
							"RE-REGISTER: Notification flag detected during debounce - skipping re-registration",
						);
						return;
					}

					// Check service status - this is the most reliable check for active calls
					// Wait for result before proceeding
					let serviceRunning = false;
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins &&
						window.Capacitor.Plugins.CallService
					) {
						try {
							const CallService =
								window.Capacitor.Plugins.CallService;
							const result = await CallService.isServiceRunning();
							if (result && result.isRunning === true) {
								serviceRunning = true;
								log(
									"RE-REGISTER: CallForegroundService is running (active call) - skipping re-registration during debounce",
								);
								return;
							}
						} catch (err) {
							log(
								"Failed to check service status in debounce: " +
									err.message,
							);
						}
					}

					// Double-check again before executing (in case call started during debounce period)
					if (currentSession) {
						const hasRequest =
							currentSession.request !== null &&
							currentSession.request !== undefined;
						const hasDialog =
							currentSession.dialog !== null &&
							currentSession.dialog !== undefined;
						const hasPeerConnection =
							currentSession.sessionDescriptionHandler &&
							currentSession.sessionDescriptionHandler
								.peerConnection !== null &&
							currentSession.sessionDescriptionHandler
								.peerConnection !== undefined;
						const isActive =
							hasRequest || hasDialog || hasPeerConnection;

						if (isActive) {
							log(
								"RE-REGISTER: Active call detected during debounce (currentSession exists with request/dialog/connection) - skipping re-registration",
							);
							return;
						} else {
							log(
								"RE-REGISTER: Found stale currentSession during debounce - clearing and will proceed",
							);
							currentSession = null;
						}
					}
					executeReRegister();
				}, 500);

				log(
					"Re-registration debounced - will execute in 500ms if no new calls",
				);
			}

			// Actual re-registration logic
			async function executeReRegister() {
				log("=== EXECUTING RE-REGISTER ===");

				// If registration already in progress, skip
				if (registrationPromise) {
					log(
						"Registration already in progress - skipping re-registration",
					);
					return;
				}

				// CRITICAL: Do not re-register if there's an active call!
				// Check currentSession - if it exists with request/dialog/peerConnection, it's active
				// The foreground service keeps the WebSocket alive during calls,
				// and unregistering would terminate the active call
				if (currentSession) {
					const hasRequest =
						currentSession.request !== null &&
						currentSession.request !== undefined;
					const hasDialog =
						currentSession.dialog !== null &&
						currentSession.dialog !== undefined;
					const hasPeerConnection =
						currentSession.sessionDescriptionHandler &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== null &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== undefined;
					const isActive =
						hasRequest || hasDialog || hasPeerConnection;

					if (isActive) {
						log(
							"Active call detected - COMPLETELY SKIPPING re-registration",
						);
						log(
							"SIP.js will automatically handle registration refresh in background",
						);
						log("Re-registration will be deferred until call ends");
						return;
					} else {
						log(
							"Found stale currentSession reference in executeReRegister (no request/dialog/connection) - clearing and will proceed",
						);
						currentSession = null;
					}
				}

				const username = document.getElementById("username").value;
				const password = document.getElementById("password").value;
				log(
					"Credentials check - username: " +
						(username ? "present" : "missing") +
						", password: " +
						(password ? "present" : "missing"),
				);

				if (!username || !password) {
					log("No credentials available for re-registration");
					return;
				}
				// Only re-register if no active call - WebSocket should still be alive during calls due to foreground service
				log(
					"No active call - checking if re-registration is needed...",
				);

				// Check if we're already registered and the connection seems healthy
				if (
					isRegistered &&
					userAgent &&
					userAgent.transport &&
					userAgent.transport.ws
				) {
					const ws = userAgent.transport.ws;
					if (ws.readyState === WebSocket.OPEN) {
						log(
							"WebSocket connection is healthy (readyState: OPEN)",
						);
						log(
							"SIP.js will automatically refresh registration - no action needed",
						);
						return;
					} else {
						log(
							"WebSocket connection is not open (readyState: " +
								ws.readyState +
								") - will re-register",
						);
					}
				}

				log("Re-registering with fresh WebSocket connection...");

				// FINAL SAFETY CHECK: Do not unregister if there's an active call!
				// This is a critical check to prevent terminating active calls
				if (currentSession) {
					const hasRequest =
						currentSession.request !== null &&
						currentSession.request !== undefined;
					const hasDialog =
						currentSession.dialog !== null &&
						currentSession.dialog !== undefined;
					const hasPeerConnection =
						currentSession.sessionDescriptionHandler &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== null &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== undefined;
					const isActive =
						hasRequest || hasDialog || hasPeerConnection;

					if (isActive) {
						log(
							"FINAL CHECK: Active call detected before unregister (request/dialog/connection) - ABORTING re-registration",
						);
						return;
					} else {
						log(
							"FINAL CHECK: Found stale currentSession before unregister - clearing and will proceed",
						);
						currentSession = null;
					}
				}

				log("Re-registering with fresh WebSocket connection...");

				// Clean up any existing connection first
				if (userAgent) {
					try {
						await unregister(); // Wait for unregistration to complete
						log("Cleaned up old connection");
					} catch (err) {
						log("Error cleaning up old connection: " + err);
					}
				}

				// FINAL SAFETY CHECK: Do not register if call started during unregistration
				if (currentSession) {
					const hasRequest =
						currentSession.request !== null &&
						currentSession.request !== undefined;
					const hasDialog =
						currentSession.dialog !== null &&
						currentSession.dialog !== undefined;
					const hasPeerConnection =
						currentSession.sessionDescriptionHandler &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== null &&
						currentSession.sessionDescriptionHandler
							.peerConnection !== undefined;
					const isActive =
						hasRequest || hasDialog || hasPeerConnection;

					if (isActive) {
						log(
							"FINAL CHECK: Active call detected during cleanup - ABORTING re-registration",
						);
						return;
					}
				}

				// Now register with proper promise handling
				try {
					log("Registering with fresh WebSocket connection...");
					await register(); // Wait for registration to complete
					log("Re-registration completed successfully");
				} catch (error) {
					log("Re-registration failed: " + error.message);
				}
			}

			// WebSocket connection monitoring
			function setupWebSocketMonitoring() {
				log("Setting up WebSocket connection monitoring...");

				// Monitor WebSocket connection status
				setInterval(() => {
					if (userAgent && isRegistered) {
						// Check if WebSocket is still connected
						if (userAgent.transport && userAgent.transport.ws) {
							if (
								userAgent.transport.ws.readyState ===
									WebSocket.CLOSED ||
								userAgent.transport.ws.readyState ===
									WebSocket.CLOSING
							) {
								log(
									"WebSocket connection lost - will re-register on next foreground",
								);
								// Mark as not registered so re-registration will happen
								isRegistered = false;
								// IMPORTANT: Clear registration promise if WebSocket died
								registrationPromise = null;
							}
						}
					}
				}, 5000); // Check every 5 seconds
			}

			// Bluetooth audio management
			function setupBluetoothAudio() {
				try {
					// Create audio context for Bluetooth audio
					bluetoothAudioContext = new (window.AudioContext ||
						window.webkitAudioContext)();
					bluetoothAudioGain = bluetoothAudioContext.createGain();
					bluetoothAudioGain.connect(
						bluetoothAudioContext.destination,
					);

					log("Bluetooth audio context initialized");
				} catch (error) {
					log("Bluetooth audio setup failed: " + error.message);
				}
			}

			function handleBluetoothAudio() {
				if (bluetoothAudioContext && bluetoothAudioGain) {
					// Route audio through Bluetooth when available
					bluetoothAudioGain.gain.value = 1.0;
					log("Audio routed through Bluetooth");
				}
			}

			function handleBluetoothDisconnect() {
				if (bluetoothAudioGain) {
					// Reduce gain when Bluetooth disconnects
					bluetoothAudioGain.gain.value = 0.5;
					log("Bluetooth disconnected - audio routed to speaker");
				}
			}

			// Configure audio session for lock screen continuity
			function configureAudioSession() {
				try {
					// Request audio focus for phone calls
					if (
						navigator.mediaDevices &&
						navigator.mediaDevices.getUserMedia
					) {
						// Set audio constraints for phone calls
						const audioConstraints = {
							audio: {
								echoCancellation: true,
								noiseSuppression: true,
								autoGainControl: true,
								// Request audio focus for phone calls
								channelCount: 1,
								sampleRate: 8000,
							},
						};

						log(
							"Audio session configured for lock screen continuity",
						);

						// Set up visibility change handler for audio management
						document.addEventListener(
							"visibilitychange",
							function () {
								if (currentSession && !document.hidden) {
									// App came back to foreground - ensure audio is still working
									log(
										"App returned to foreground - checking audio session",
									);
									handleBluetoothAudio();
								}
							},
						);
					}
				} catch (error) {
					log("Error configuring audio session: " + error.message);
				}
			}

			// Wake lock management for call continuity
			let wakeLock = null;

			async function requestWakeLock() {
				try {
					if ("wakeLock" in navigator) {
						wakeLock = await navigator.wakeLock.request("screen");
						log(
							"Wake lock acquired - screen will stay on during call",
						);

						wakeLock.addEventListener("release", () => {
							log("Wake lock released");
						});
					} else {
						log("Wake lock API not supported");
					}
				} catch (error) {
					log("Wake lock failed: " + error.message);
				}
			}

			async function releaseWakeLock() {
				try {
					if (wakeLock) {
						await wakeLock.release();
						wakeLock = null;
						log("Wake lock released");
					}
				} catch (error) {
					log("Error releasing wake lock: " + error.message);
				}
			}

			// Android foreground service management for call continuity
			async function startCallService(callNumber) {
				try {
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins &&
						window.Capacitor.Plugins.CallService
					) {
						const CallService =
							window.Capacitor.Plugins.CallService;
						await CallService.startCall({
							callNumber: callNumber || "",
						});
						log("Android call service started");
					}
				} catch (error) {
					log("Failed to start call service: " + error.message);
					console.error("CallService error:", error);
				}
			}

			async function stopCallService() {
				try {
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins &&
						window.Capacitor.Plugins.CallService
					) {
						const CallService =
							window.Capacitor.Plugins.CallService;
						await CallService.stopCall();
						log("Android call service stopped");
					}
				} catch (error) {
					log("Failed to stop call service: " + error.message);
					console.error("CallService error:", error);
				}
			}

			async function updateCallServiceNumber(callNumber) {
				try {
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins &&
						window.Capacitor.Plugins.CallService
					) {
						const CallService =
							window.Capacitor.Plugins.CallService;
						await CallService.updateCallNumber({
							callNumber: callNumber || "",
						});
						log("Android call service number updated");
					}
				} catch (error) {
					log(
						"Failed to update call service number: " +
							error.message,
					);
				}
			}

			// Incoming call notification management
			async function showIncomingCallNotification(
				callerName,
				callerNumber,
			) {
				log(`[CallKit] showIncomingCallNotification called: name=${callerName}, number=${callerNumber}`);
				try {
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins
					) {
						log(`[CallKit] Checking for plugins...`);
						log(`[CallKit] VTCallService exists: ${!!window.Capacitor.Plugins.VTCallService}`);
						log(`[CallKit] CallService exists: ${!!window.Capacitor.Plugins.CallService}`);
						
						// Try VTCallService first (iOS), then CallService (Android)
						const CallService =
							window.Capacitor.Plugins.VTCallService ||
							window.Capacitor.Plugins.CallService;
						
						if (CallService) {
							log(`[CallKit] Plugin found, calling showIncomingCallNotification...`);
							await CallService.showIncomingCallNotification({
								callerName: callerName || "Unknown",
								callerNumber: callerNumber || "",
							});
							log("‚úÖ [CallKit] Incoming call notification displayed");
						} else {
							log("‚ö†Ô∏è [CallKit] No CallService plugin available");
						}
					} else {
						log("‚ö†Ô∏è [CallKit] Not native platform or Capacitor not available");
					}
				} catch (error) {
					log(
						"‚ùå [CallKit] Failed to show incoming call notification: " +
							error.message,
					);
					console.error("Notification error:", error);
				}
			}

			async function dismissIncomingCallNotification() {
				try {
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins
					) {
						// Try VTCallService first (iOS), then CallService (Android)
						const CallService =
							window.Capacitor.Plugins.VTCallService ||
							window.Capacitor.Plugins.CallService;
						if (CallService) {
							await CallService.dismissIncomingCallNotification();
							log("Incoming call notification dismissed");
						}
					}
				} catch (error) {
					log(
						"Failed to dismiss incoming call notification: " +
							error.message,
					);
					console.error("Notification error:", error);
				}
			}

			async function reportCallConnected() {
				try {
					if (
						window.Capacitor &&
						window.Capacitor.isNativePlatform() &&
						window.Capacitor.Plugins
					) {
						// Try VTCallService first (iOS), then CallService (Android)
						const CallService =
							window.Capacitor.Plugins.VTCallService ||
							window.Capacitor.Plugins.CallService;
						if (CallService) {
							// iOS: reportCallConnected stops CallKit ringtone
							// Android: dismissIncomingCallNotification stops notification vibration
							if (CallService.reportCallConnected) {
								// iOS - report call as connected to stop CallKit ringtone
								await CallService.reportCallConnected();
								log("Call reported as connected to CallKit");
							} else {
								// Android - dismiss notification to stop vibration/ringing
								await CallService.dismissIncomingCallNotification();
								log("Incoming call notification dismissed (Android)");
							}
						}
					}
				} catch (error) {
					log(
						"Failed to report call connected: " +
							error.message,
					);
					console.error("Notification error:", error);
				}
			}

			// Track CallKit audio session state (iOS only)
			let callKitAudioSessionActive = false;
			let pendingAudioStart = false;

			// Function to start WebRTC audio playback
			function startWebRTCAudio() {
				if (!currentSession || !activeCall) {
					return;
				}

				try {
					const pc = currentSession.sessionDescriptionHandler.peerConnection;
					if (!pc) {
						return;
					}

					const remoteStream = new MediaStream();
					pc.getReceivers().forEach((receiver) => {
						if (receiver.track) {
							remoteStream.addTrack(receiver.track);
						}
					});

					const remoteAudio = document.getElementById("remoteAudio");
					if (!remoteAudio) {
						return;
					}

					remoteAudio.srcObject = remoteStream;
					remoteAudio.volume = 1.0;
					remoteAudio.muted = false;

					remoteAudio.play().then(() => {
						log("‚úÖ [CallKit] Remote audio playing successfully");
					}).catch((err) => {
						log("‚ùå [CallKit] Error playing remote audio: " + err.message);
					});
				} catch (e) {
					log("‚ùå [CallKit] Error starting WebRTC audio: " + e.message);
				}
			}

			// Handle notification actions (Answer/Decline from notification)
			window.handleNotificationAction = function (action, data) {
				log("Notification action received: " + action);

				if (action === "ANSWER_CALL") {
					if (incomingSession) {
						answerCall();
					} else {
						log("No incoming call to answer");
					}
				} else if (action === "DECLINE_CALL") {
					if (incomingSession) {
						declineCall();
					} else {
						log("No incoming call to decline");
					}
				} else if (action === "HANGUP") {
					if (currentSession) {
						hangup();
					} else {
						log("No active call to hang up");
					}
				} else if (action === "AUDIO_SESSION_ACTIVATED") {
					log("‚úÖ [CallKit] Audio session activated");
					callKitAudioSessionActive = true;
					if (pendingAudioStart || (currentSession && activeCall)) {
						pendingAudioStart = false;
						startWebRTCAudio();
					}
				} else if (action === "AUDIO_SESSION_DEACTIVATED") {
					log("‚ÑπÔ∏è [CallKit] Audio session deactivated");
					callKitAudioSessionActive = false;
				}
			};

			// Setup audio session for lock screen continuity
			function setupAudioSession() {
				try {
					// Configure audio context for phone calls
					if (window.AudioContext || window.webkitAudioContext) {
						const AudioContext =
							window.AudioContext || window.webkitAudioContext;
						const audioContext = new AudioContext();

						// Set audio context state to running
						if (audioContext.state === "suspended") {
							audioContext.resume().then(() => {
								log(
									"Audio context resumed for lock screen continuity",
								);
							});
						}

						// Handle visibility changes for audio context
						document.addEventListener(
							"visibilitychange",
							function () {
								if (
									audioContext.state === "suspended" &&
									currentSession
								) {
									audioContext.resume().then(() => {
										log(
											"Audio context resumed on visibility change",
										);
									});
								}
							},
						);
					}

					log("Audio session setup completed");
				} catch (error) {
					log("Error setting up audio session: " + error.message);
				}
			}

			// Initialize on DOM load
			window.addEventListener("DOMContentLoaded", async function () {
				if (typeof SIP === "undefined") {
					console.error("SIP.js library failed to load");
					log("Error: SIP.js library not loaded");
					alert(
						"SIP.js library failed to load. Please check your internet connection and refresh.",
					);
					return;
				}

				document.title = `VoiceTel Phone v${APP_VERSION}`;
				log(`VoiceTel Phone v${APP_VERSION} ready`);
				log("Using local storage");
				log("SIP.js " + (SIP.version || "0.15.x") + " loaded");
				// Initialize SIP server hidden field and info display
				const sipServerEl = document.getElementById("sipServer");
				if (sipServerEl) sipServerEl.value = SIP_SERVER;
				log(`Server: ${SIP_DOMAIN} (${SIP_SERVER})`);

				// Load saved configuration
				await Storage.loadConfig();

				// Setup app state listeners for re-registration
				log("=== CALLING setupAppStateListeners ===");
				console.log("=== JAVASCRIPT IS RUNNING ===");
				setupAppStateListeners();
				log("=== setupAppStateListeners COMPLETED ===");

				// Setup audio session for lock screen continuity
				setupAudioSession();

				// Setup WebSocket connection monitoring
				setupWebSocketMonitoring();

				// Setup contact search functionality
				setupContactSearch();

				// Auto-load contacts on startup
				log("Auto-loading contacts on startup...");
				loadContacts();

				// Ensure event log visibility is set correctly after everything is loaded
				setTimeout(() => {
					console.log(
						"Final updateEventLogVisibility call after initialization",
					);
					updateEventLogVisibility();
				}, 100);

				// Debug: Log what's available
				log(
					"Window.Capacitor available: " +
						(window.Capacitor ? "Yes" : "No"),
				);
				if (window.Capacitor) {
					log(
						"Capacitor.isNativePlatform: " +
							window.Capacitor.isNativePlatform(),
					);
					log(
						"Capacitor.Plugins available: " +
							(window.Capacitor.Plugins ? "Yes" : "No"),
					);
					if (window.Capacitor.Plugins) {
						log(
							"Capacitor.Plugins.App available: " +
								(window.Capacitor.Plugins.App ? "Yes" : "No"),
						);
					}
				}

				// Duplicate listeners removed - only using the main setup above

				// Duplicate listeners removed - only using the main setup above

				// Setup Bluetooth audio
				setupBluetoothAudio();

				// Setup input handlers
				document
					.getElementById("username")
					.addEventListener("input", function (e) {
						const value = e.target.value.replace(/\D/g, "");
						e.target.value = value.substring(0, USERNAME_LENGTH);

						const errorEl =
							document.getElementById("usernameError");
						if (value && value.length !== USERNAME_LENGTH) {
							errorEl.style.display = "block";
						} else {
							errorEl.style.display = "none";
						}
					});

				document
					.getElementById("callerID")
					.addEventListener("input", function (e) {
						const value = e.target.value.replace(/\D/g, "");
						e.target.value = value.substring(0, USERNAME_LENGTH);

						const errorEl =
							document.getElementById("callerIDError");
						if (value && !validateNorthAmericanNumber(value)) {
							errorEl.style.display = "block";
						} else {
							errorEl.style.display = "none";
						}
					});

				// Auto-save on change
				[
					"username",
					"password",
					"displayName",
					"callerID",
					"hideCallerID",
					"saveCredentials",
					"registerOnStartup",
					"hideEventLog",
					"enableCallRecording",
				].forEach((id) => {
					const el = document.getElementById(id);
					if (el) {
						el.addEventListener("change", () => {
							Storage.saveConfig();
							// Update event log visibility when hideEventLog changes
							if (id === "hideEventLog") {
								updateEventLogVisibility();
							}
						});
					}
				});

				// Keyboard shortcuts for incoming calls
				document.addEventListener("keydown", function (e) {
					if (incomingSession) {
						if (e.key === "Enter" || e.key === " ") {
							e.preventDefault();
							answerCall();
						} else if (e.key === "Escape") {
							e.preventDefault();
							declineCall();
						}
					}
				});
			});

			// Cleanup function for proper resource management
			function cleanupAllResources() {
				// Clear all timeouts
				if (incomingCallTimeout) {
					clearTimeout(incomingCallTimeout);
					incomingCallTimeout = null;
				}

				// Clean up WebSocket event listeners
				if (
					userAgent &&
					userAgent.transport &&
					userAgent.transport.ws &&
					webSocketMessageHandler
				) {
					userAgent.transport.ws.removeEventListener(
						"message",
						webSocketMessageHandler,
					);
					webSocketMessageHandler = null;
				}

				// Clean up SIP sessions
				if (incomingSession) {
					try {
						incomingSession.reject();
					} catch (e) {}
					incomingSession = null;
				}
				if (currentSession) {
					try {
						currentSession.bye();
					} catch (e) {}
					currentSession = null;
				}
				if (userAgent) {
					try {
						userAgent.stop();
					} catch (e) {}
					userAgent = null;
				}

				// Reset all state
				isRegistered = false;
				registeredUsername = null;
				__callDirection = null;
				__answeredIncoming = false;
				__incomingRaw = null;
				__incomingDisplay = null;
			}

			// Cleanup on window close
			window.addEventListener("beforeunload", () => {
				cleanupAllResources();
			});
		</script>
	</body>
</html>
